/*
 * The Jira Cloud platform REST API
 * Jira Cloud platform REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0-SNAPSHOT-9aad01a33a3dae75a5b6aedf98c77d2cbd2f865d
 * Contact: ecosystem@atlassian.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.IdSearchRequestBean;
import com.konfigthis.client.model.IdSearchResults;
import com.konfigthis.client.model.IssueMatches;
import com.konfigthis.client.model.IssuePickerSuggestions;
import com.konfigthis.client.model.IssuesAndJQLQueries;
import com.konfigthis.client.model.SearchRequestBean;
import com.konfigthis.client.model.SearchResults;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class IssueSearchApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public IssueSearchApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public IssueSearchApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call checkAgainstJqlCall(IssuesAndJQLQueries issuesAndJQLQueries, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = issuesAndJQLQueries;

        // create path and map variables
        String localVarPath = "/rest/api/3/jql/match";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call checkAgainstJqlValidateBeforeCall(IssuesAndJQLQueries issuesAndJQLQueries, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issuesAndJQLQueries' is set
        if (issuesAndJQLQueries == null) {
            throw new ApiException("Missing the required parameter 'issuesAndJQLQueries' when calling checkAgainstJql(Async)");
        }

        return checkAgainstJqlCall(issuesAndJQLQueries, _callback);

    }


    private ApiResponse<IssueMatches> checkAgainstJqlWithHttpInfo(IssuesAndJQLQueries issuesAndJQLQueries) throws ApiException {
        okhttp3.Call localVarCall = checkAgainstJqlValidateBeforeCall(issuesAndJQLQueries, null);
        Type localVarReturnType = new TypeToken<IssueMatches>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call checkAgainstJqlAsync(IssuesAndJQLQueries issuesAndJQLQueries, final ApiCallback<IssueMatches> _callback) throws ApiException {

        okhttp3.Call localVarCall = checkAgainstJqlValidateBeforeCall(issuesAndJQLQueries, _callback);
        Type localVarReturnType = new TypeToken<IssueMatches>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CheckAgainstJqlRequestBuilder {
        private final Set<Long> issueIds;
        private final List<String> jqls;

        private CheckAgainstJqlRequestBuilder(Set<Long> issueIds, List<String> jqls) {
            this.issueIds = issueIds;
            this.jqls = jqls;
        }

        /**
         * Build call for checkAgainstJql
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if &#x60;jqls&#x60; exceeds the maximum number of JQL queries or &#x60;issueIds&#x60; exceeds the maximum number of issue IDs. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            IssuesAndJQLQueries issuesAndJQLQueries = buildBodyParams();
            return checkAgainstJqlCall(issuesAndJQLQueries, _callback);
        }

        private IssuesAndJQLQueries buildBodyParams() {
            IssuesAndJQLQueries issuesAndJQLQueries = new IssuesAndJQLQueries();
            issuesAndJQLQueries.issueIds(this.issueIds);
            issuesAndJQLQueries.jqls(this.jqls);
            return issuesAndJQLQueries;
        }

        /**
         * Execute checkAgainstJql request
         * @return IssueMatches
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if &#x60;jqls&#x60; exceeds the maximum number of JQL queries or &#x60;issueIds&#x60; exceeds the maximum number of issue IDs. </td><td>  -  </td></tr>
         </table>
         */
        public IssueMatches execute() throws ApiException {
            IssuesAndJQLQueries issuesAndJQLQueries = buildBodyParams();
            ApiResponse<IssueMatches> localVarResp = checkAgainstJqlWithHttpInfo(issuesAndJQLQueries);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute checkAgainstJql request with HTTP info returned
         * @return ApiResponse&lt;IssueMatches&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if &#x60;jqls&#x60; exceeds the maximum number of JQL queries or &#x60;issueIds&#x60; exceeds the maximum number of issue IDs. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<IssueMatches> executeWithHttpInfo() throws ApiException {
            IssuesAndJQLQueries issuesAndJQLQueries = buildBodyParams();
            return checkAgainstJqlWithHttpInfo(issuesAndJQLQueries);
        }

        /**
         * Execute checkAgainstJql request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if &#x60;jqls&#x60; exceeds the maximum number of JQL queries or &#x60;issueIds&#x60; exceeds the maximum number of issue IDs. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<IssueMatches> _callback) throws ApiException {
            IssuesAndJQLQueries issuesAndJQLQueries = buildBodyParams();
            return checkAgainstJqlAsync(issuesAndJQLQueries, _callback);
        }
    }

    /**
     * Check issues against JQL
     * Checks whether one or more issues would be returned by one or more JQL queries.  **[Permissions](https://dac-static.atlassian.com) required:** None, however, issues are only matched against JQL queries where the user has:   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * @param issuesAndJQLQueries  (required)
     * @return CheckAgainstJqlRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if &#x60;jqls&#x60; exceeds the maximum number of JQL queries or &#x60;issueIds&#x60; exceeds the maximum number of issue IDs. </td><td>  -  </td></tr>
     </table>
     */
    public CheckAgainstJqlRequestBuilder checkAgainstJql(Set<Long> issueIds, List<String> jqls) throws IllegalArgumentException {
        if (issueIds == null) throw new IllegalArgumentException("\"issueIds\" is required but got null");
        if (jqls == null) throw new IllegalArgumentException("\"jqls\" is required but got null");
        return new CheckAgainstJqlRequestBuilder(issueIds, jqls);
    }
    private okhttp3.Call jqlGetCall(String jql, Integer startAt, Integer maxResults, String validateQuery, List<String> fields, String expand, List<String> properties, Boolean fieldsByKeys, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (jql != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("jql", jql));
        }

        if (startAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startAt", startAt));
        }

        if (maxResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxResults", maxResults));
        }

        if (validateQuery != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("validateQuery", validateQuery));
        }

        if (fields != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "fields", fields));
        }

        if (expand != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expand", expand));
        }

        if (properties != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "properties", properties));
        }

        if (fieldsByKeys != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fieldsByKeys", fieldsByKeys));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call jqlGetValidateBeforeCall(String jql, Integer startAt, Integer maxResults, String validateQuery, List<String> fields, String expand, List<String> properties, Boolean fieldsByKeys, final ApiCallback _callback) throws ApiException {
        return jqlGetCall(jql, startAt, maxResults, validateQuery, fields, expand, properties, fieldsByKeys, _callback);

    }


    private ApiResponse<SearchResults> jqlGetWithHttpInfo(String jql, Integer startAt, Integer maxResults, String validateQuery, List<String> fields, String expand, List<String> properties, Boolean fieldsByKeys) throws ApiException {
        okhttp3.Call localVarCall = jqlGetValidateBeforeCall(jql, startAt, maxResults, validateQuery, fields, expand, properties, fieldsByKeys, null);
        Type localVarReturnType = new TypeToken<SearchResults>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call jqlGetAsync(String jql, Integer startAt, Integer maxResults, String validateQuery, List<String> fields, String expand, List<String> properties, Boolean fieldsByKeys, final ApiCallback<SearchResults> _callback) throws ApiException {

        okhttp3.Call localVarCall = jqlGetValidateBeforeCall(jql, startAt, maxResults, validateQuery, fields, expand, properties, fieldsByKeys, _callback);
        Type localVarReturnType = new TypeToken<SearchResults>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class JqlGetRequestBuilder {
        private String jql;
        private Integer startAt;
        private Integer maxResults;
        private String validateQuery;
        private List<String> fields;
        private String expand;
        private List<String> properties;
        private Boolean fieldsByKeys;

        private JqlGetRequestBuilder() {
        }

        /**
         * Set jql
         * @param jql The [JQL](https://confluence.atlassian.com/x/egORLQ) that defines the search. Note:   *  If no JQL expression is provided, all issues are returned.  *  &#x60;username&#x60; and &#x60;userkey&#x60; cannot be used as search terms due to privacy reasons. Use &#x60;accountId&#x60; instead.  *  If a user has hidden their email address in their user profile, partial matches of the email address will not find the user. An exact match is required. (optional)
         * @return JqlGetRequestBuilder
         */
        public JqlGetRequestBuilder jql(String jql) {
            this.jql = jql;
            return this;
        }
        
        /**
         * Set startAt
         * @param startAt The index of the first item to return in a page of results (page offset). (optional, default to 0)
         * @return JqlGetRequestBuilder
         */
        public JqlGetRequestBuilder startAt(Integer startAt) {
            this.startAt = startAt;
            return this;
        }
        
        /**
         * Set maxResults
         * @param maxResults The maximum number of items to return per page. To manage page size, Jira may return fewer items per page where a large number of fields are requested. The greatest number of items returned per page is achieved when requesting &#x60;id&#x60; or &#x60;key&#x60; only. (optional, default to 50)
         * @return JqlGetRequestBuilder
         */
        public JqlGetRequestBuilder maxResults(Integer maxResults) {
            this.maxResults = maxResults;
            return this;
        }
        
        /**
         * Set validateQuery
         * @param validateQuery Determines how to validate the JQL query and treat the validation results. Supported values are:   *  &#x60;strict&#x60; Returns a 400 response code if any errors are found, along with a list of all errors (and warnings).  *  &#x60;warn&#x60; Returns all errors as warnings.  *  &#x60;none&#x60; No validation is performed.  *  &#x60;true&#x60; *Deprecated* A legacy synonym for &#x60;strict&#x60;.  *  &#x60;false&#x60; *Deprecated* A legacy synonym for &#x60;warn&#x60;.  Note: If the JQL is not correctly formed a 400 response code is returned, regardless of the &#x60;validateQuery&#x60; value. (optional, default to strict)
         * @return JqlGetRequestBuilder
         */
        public JqlGetRequestBuilder validateQuery(String validateQuery) {
            this.validateQuery = validateQuery;
            return this;
        }
        
        /**
         * Set fields
         * @param fields A list of fields to return for each issue, use it to retrieve a subset of fields. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;*all&#x60; Returns all fields.  *  &#x60;*navigable&#x60; Returns navigable fields.  *  Any issue field, prefixed with a minus to exclude.  Examples:   *  &#x60;summary,comment&#x60; Returns only the summary and comments fields.  *  &#x60;-description&#x60; Returns all navigable (default) fields except description.  *  &#x60;*all,-comment&#x60; Returns all fields except comments.  This parameter may be specified multiple times. For example, &#x60;fields&#x3D;field1,field2&amp;fields&#x3D;field3&#x60;.  Note: All navigable fields are returned by default. This differs from [GET issue](https://dac-static.atlassian.com) where the default is all fields. (optional)
         * @return JqlGetRequestBuilder
         */
        public JqlGetRequestBuilder fields(List<String> fields) {
            this.fields = fields;
            return this;
        }
        
        /**
         * Set expand
         * @param expand Use [expand](https://dac-static.atlassian.com) to include additional information about issues in the response. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;renderedFields&#x60; Returns field values rendered in HTML format.  *  &#x60;names&#x60; Returns the display name of each field.  *  &#x60;schema&#x60; Returns the schema describing a field type.  *  &#x60;transitions&#x60; Returns all possible transitions for the issue.  *  &#x60;operations&#x60; Returns all possible operations for the issue.  *  &#x60;editmeta&#x60; Returns information about how each field can be edited.  *  &#x60;changelog&#x60; Returns a list of recent updates to an issue, sorted by date, starting from the most recent.  *  &#x60;versionedRepresentations&#x60; Instead of &#x60;fields&#x60;, returns &#x60;versionedRepresentations&#x60; a JSON array containing each version of a field&#39;s value, with the highest numbered item representing the most recent version. (optional)
         * @return JqlGetRequestBuilder
         */
        public JqlGetRequestBuilder expand(String expand) {
            this.expand = expand;
            return this;
        }
        
        /**
         * Set properties
         * @param properties A list of issue property keys for issue properties to include in the results. This parameter accepts a comma-separated list. Multiple properties can also be provided using an ampersand separated list. For example, &#x60;properties&#x3D;prop1,prop2&amp;properties&#x3D;prop3&#x60;. A maximum of 5 issue property keys can be specified. (optional)
         * @return JqlGetRequestBuilder
         */
        public JqlGetRequestBuilder properties(List<String> properties) {
            this.properties = properties;
            return this;
        }
        
        /**
         * Set fieldsByKeys
         * @param fieldsByKeys Reference fields by their key (rather than ID). (optional, default to false)
         * @return JqlGetRequestBuilder
         */
        public JqlGetRequestBuilder fieldsByKeys(Boolean fieldsByKeys) {
            this.fieldsByKeys = fieldsByKeys;
            return this;
        }
        
        /**
         * Build call for jqlGet
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the JQL query is invalid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return jqlGetCall(jql, startAt, maxResults, validateQuery, fields, expand, properties, fieldsByKeys, _callback);
        }


        /**
         * Execute jqlGet request
         * @return SearchResults
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the JQL query is invalid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public SearchResults execute() throws ApiException {
            ApiResponse<SearchResults> localVarResp = jqlGetWithHttpInfo(jql, startAt, maxResults, validateQuery, fields, expand, properties, fieldsByKeys);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute jqlGet request with HTTP info returned
         * @return ApiResponse&lt;SearchResults&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the JQL query is invalid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<SearchResults> executeWithHttpInfo() throws ApiException {
            return jqlGetWithHttpInfo(jql, startAt, maxResults, validateQuery, fields, expand, properties, fieldsByKeys);
        }

        /**
         * Execute jqlGet request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the JQL query is invalid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<SearchResults> _callback) throws ApiException {
            return jqlGetAsync(jql, startAt, maxResults, validateQuery, fields, expand, properties, fieldsByKeys, _callback);
        }
    }

    /**
     * Search for issues using JQL (GET)
     * Searches for issues using [JQL](https://confluence.atlassian.com/x/egORLQ).  If the JQL query expression is too large to be encoded as a query parameter, use the [POST](https://dac-static.atlassian.com) version of this resource.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:** Issues are included in the response where the user has:   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * @return JqlGetRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if the JQL query is invalid. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
     </table>
     */
    public JqlGetRequestBuilder jqlGet() throws IllegalArgumentException {
        return new JqlGetRequestBuilder();
    }
    private okhttp3.Call pickerSuggestionsGetCall(String query, String currentJQL, String currentIssueKey, String currentProjectId, Boolean showSubTasks, Boolean showSubTaskParent, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/picker";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (currentJQL != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currentJQL", currentJQL));
        }

        if (currentIssueKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currentIssueKey", currentIssueKey));
        }

        if (currentProjectId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("currentProjectId", currentProjectId));
        }

        if (showSubTasks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("showSubTasks", showSubTasks));
        }

        if (showSubTaskParent != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("showSubTaskParent", showSubTaskParent));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call pickerSuggestionsGetValidateBeforeCall(String query, String currentJQL, String currentIssueKey, String currentProjectId, Boolean showSubTasks, Boolean showSubTaskParent, final ApiCallback _callback) throws ApiException {
        return pickerSuggestionsGetCall(query, currentJQL, currentIssueKey, currentProjectId, showSubTasks, showSubTaskParent, _callback);

    }


    private ApiResponse<IssuePickerSuggestions> pickerSuggestionsGetWithHttpInfo(String query, String currentJQL, String currentIssueKey, String currentProjectId, Boolean showSubTasks, Boolean showSubTaskParent) throws ApiException {
        okhttp3.Call localVarCall = pickerSuggestionsGetValidateBeforeCall(query, currentJQL, currentIssueKey, currentProjectId, showSubTasks, showSubTaskParent, null);
        Type localVarReturnType = new TypeToken<IssuePickerSuggestions>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call pickerSuggestionsGetAsync(String query, String currentJQL, String currentIssueKey, String currentProjectId, Boolean showSubTasks, Boolean showSubTaskParent, final ApiCallback<IssuePickerSuggestions> _callback) throws ApiException {

        okhttp3.Call localVarCall = pickerSuggestionsGetValidateBeforeCall(query, currentJQL, currentIssueKey, currentProjectId, showSubTasks, showSubTaskParent, _callback);
        Type localVarReturnType = new TypeToken<IssuePickerSuggestions>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class PickerSuggestionsGetRequestBuilder {
        private String query;
        private String currentJQL;
        private String currentIssueKey;
        private String currentProjectId;
        private Boolean showSubTasks;
        private Boolean showSubTaskParent;

        private PickerSuggestionsGetRequestBuilder() {
        }

        /**
         * Set query
         * @param query A string to match against text fields in the issue such as title, description, or comments. (optional)
         * @return PickerSuggestionsGetRequestBuilder
         */
        public PickerSuggestionsGetRequestBuilder query(String query) {
            this.query = query;
            return this;
        }
        
        /**
         * Set currentJQL
         * @param currentJQL A JQL query defining a list of issues to search for the query term. Note that &#x60;username&#x60; and &#x60;userkey&#x60; cannot be used as search terms for this parameter, due to privacy reasons. Use &#x60;accountId&#x60; instead. (optional)
         * @return PickerSuggestionsGetRequestBuilder
         */
        public PickerSuggestionsGetRequestBuilder currentJQL(String currentJQL) {
            this.currentJQL = currentJQL;
            return this;
        }
        
        /**
         * Set currentIssueKey
         * @param currentIssueKey The key of an issue to exclude from search results. For example, the issue the user is viewing when they perform this query. (optional)
         * @return PickerSuggestionsGetRequestBuilder
         */
        public PickerSuggestionsGetRequestBuilder currentIssueKey(String currentIssueKey) {
            this.currentIssueKey = currentIssueKey;
            return this;
        }
        
        /**
         * Set currentProjectId
         * @param currentProjectId The ID of a project that suggested issues must belong to. (optional)
         * @return PickerSuggestionsGetRequestBuilder
         */
        public PickerSuggestionsGetRequestBuilder currentProjectId(String currentProjectId) {
            this.currentProjectId = currentProjectId;
            return this;
        }
        
        /**
         * Set showSubTasks
         * @param showSubTasks Indicate whether to include subtasks in the suggestions list. (optional)
         * @return PickerSuggestionsGetRequestBuilder
         */
        public PickerSuggestionsGetRequestBuilder showSubTasks(Boolean showSubTasks) {
            this.showSubTasks = showSubTasks;
            return this;
        }
        
        /**
         * Set showSubTaskParent
         * @param showSubTaskParent When &#x60;currentIssueKey&#x60; is a subtask, whether to include the parent issue in the suggestions if it matches the query. (optional)
         * @return PickerSuggestionsGetRequestBuilder
         */
        public PickerSuggestionsGetRequestBuilder showSubTaskParent(Boolean showSubTaskParent) {
            this.showSubTaskParent = showSubTaskParent;
            return this;
        }
        
        /**
         * Build call for pickerSuggestionsGet
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return pickerSuggestionsGetCall(query, currentJQL, currentIssueKey, currentProjectId, showSubTasks, showSubTaskParent, _callback);
        }


        /**
         * Execute pickerSuggestionsGet request
         * @return IssuePickerSuggestions
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public IssuePickerSuggestions execute() throws ApiException {
            ApiResponse<IssuePickerSuggestions> localVarResp = pickerSuggestionsGetWithHttpInfo(query, currentJQL, currentIssueKey, currentProjectId, showSubTasks, showSubTaskParent);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute pickerSuggestionsGet request with HTTP info returned
         * @return ApiResponse&lt;IssuePickerSuggestions&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<IssuePickerSuggestions> executeWithHttpInfo() throws ApiException {
            return pickerSuggestionsGetWithHttpInfo(query, currentJQL, currentIssueKey, currentProjectId, showSubTasks, showSubTaskParent);
        }

        /**
         * Execute pickerSuggestionsGet request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<IssuePickerSuggestions> _callback) throws ApiException {
            return pickerSuggestionsGetAsync(query, currentJQL, currentIssueKey, currentProjectId, showSubTasks, showSubTaskParent, _callback);
        }
    }

    /**
     * Get issue picker suggestions
     * Returns lists of issues matching a query string. Use this resource to provide auto-completion suggestions when the user is looking for an issue using a word or string.  This operation returns two lists:   *  &#x60;History Search&#x60; which includes issues from the user&#39;s history of created, edited, or viewed issues that contain the string in the &#x60;query&#x60; parameter.  *  &#x60;Current Search&#x60; which includes issues that match the JQL expression in &#x60;currentJQL&#x60; and contain the string in the &#x60;query&#x60; parameter.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:** None.
     * @return PickerSuggestionsGetRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
     </table>
     */
    public PickerSuggestionsGetRequestBuilder pickerSuggestionsGet() throws IllegalArgumentException {
        return new PickerSuggestionsGetRequestBuilder();
    }
    private okhttp3.Call searchIssueIdsUsingJqlPostCall(IdSearchRequestBean idSearchRequestBean, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = idSearchRequestBean;

        // create path and map variables
        String localVarPath = "/rest/api/3/search/id";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchIssueIdsUsingJqlPostValidateBeforeCall(IdSearchRequestBean idSearchRequestBean, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'idSearchRequestBean' is set
        if (idSearchRequestBean == null) {
            throw new ApiException("Missing the required parameter 'idSearchRequestBean' when calling searchIssueIdsUsingJqlPost(Async)");
        }

        return searchIssueIdsUsingJqlPostCall(idSearchRequestBean, _callback);

    }


    private ApiResponse<IdSearchResults> searchIssueIdsUsingJqlPostWithHttpInfo(IdSearchRequestBean idSearchRequestBean) throws ApiException {
        okhttp3.Call localVarCall = searchIssueIdsUsingJqlPostValidateBeforeCall(idSearchRequestBean, null);
        Type localVarReturnType = new TypeToken<IdSearchResults>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call searchIssueIdsUsingJqlPostAsync(IdSearchRequestBean idSearchRequestBean, final ApiCallback<IdSearchResults> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchIssueIdsUsingJqlPostValidateBeforeCall(idSearchRequestBean, _callback);
        Type localVarReturnType = new TypeToken<IdSearchResults>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SearchIssueIdsUsingJqlPostRequestBuilder {
        private String jql;
        private Integer maxResults;
        private String nextPageToken;

        private SearchIssueIdsUsingJqlPostRequestBuilder() {
        }

        /**
         * Set jql
         * @param jql A [JQL](https://confluence.atlassian.com/x/egORLQ) expression. Order by clauses are not allowed. (optional)
         * @return SearchIssueIdsUsingJqlPostRequestBuilder
         */
        public SearchIssueIdsUsingJqlPostRequestBuilder jql(String jql) {
            this.jql = jql;
            return this;
        }
        
        /**
         * Set maxResults
         * @param maxResults The maximum number of items to return per page. (optional, default to 1000)
         * @return SearchIssueIdsUsingJqlPostRequestBuilder
         */
        public SearchIssueIdsUsingJqlPostRequestBuilder maxResults(Integer maxResults) {
            this.maxResults = maxResults;
            return this;
        }
        
        /**
         * Set nextPageToken
         * @param nextPageToken The continuation token to fetch the next page. This token is provided by the response of this endpoint. (optional)
         * @return SearchIssueIdsUsingJqlPostRequestBuilder
         */
        public SearchIssueIdsUsingJqlPostRequestBuilder nextPageToken(String nextPageToken) {
            this.nextPageToken = nextPageToken;
            return this;
        }
        
        /**
         * Build call for searchIssueIdsUsingJqlPost
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the JQL query is invalid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            IdSearchRequestBean idSearchRequestBean = buildBodyParams();
            return searchIssueIdsUsingJqlPostCall(idSearchRequestBean, _callback);
        }

        private IdSearchRequestBean buildBodyParams() {
            IdSearchRequestBean idSearchRequestBean = new IdSearchRequestBean();
            idSearchRequestBean.jql(this.jql);
            idSearchRequestBean.maxResults(this.maxResults);
            idSearchRequestBean.nextPageToken(this.nextPageToken);
            return idSearchRequestBean;
        }

        /**
         * Execute searchIssueIdsUsingJqlPost request
         * @return IdSearchResults
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the JQL query is invalid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public IdSearchResults execute() throws ApiException {
            IdSearchRequestBean idSearchRequestBean = buildBodyParams();
            ApiResponse<IdSearchResults> localVarResp = searchIssueIdsUsingJqlPostWithHttpInfo(idSearchRequestBean);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute searchIssueIdsUsingJqlPost request with HTTP info returned
         * @return ApiResponse&lt;IdSearchResults&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the JQL query is invalid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<IdSearchResults> executeWithHttpInfo() throws ApiException {
            IdSearchRequestBean idSearchRequestBean = buildBodyParams();
            return searchIssueIdsUsingJqlPostWithHttpInfo(idSearchRequestBean);
        }

        /**
         * Execute searchIssueIdsUsingJqlPost request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the JQL query is invalid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<IdSearchResults> _callback) throws ApiException {
            IdSearchRequestBean idSearchRequestBean = buildBodyParams();
            return searchIssueIdsUsingJqlPostAsync(idSearchRequestBean, _callback);
        }
    }

    /**
     * Search issue IDs using JQL
     * Searches for IDs of issues using [JQL](https://confluence.atlassian.com/x/egORLQ).  Use the [Search](https://dac-static.atlassian.com) endpoint if you need to fetch more than just issue IDs. The Search endpoint returns more information, but may take much longer to respond to requests. This is because it uses a different mechanism for ordering results than this endpoint and doesn&#39;t provide the total number of results for your query.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:** Issues are included in the response where the user has:   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * @param idSearchRequestBean A JSON object containing the search request. (required)
     * @return SearchIssueIdsUsingJqlPostRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if the JQL query is invalid. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
     </table>
     */
    public SearchIssueIdsUsingJqlPostRequestBuilder searchIssueIdsUsingJqlPost() throws IllegalArgumentException {
        return new SearchIssueIdsUsingJqlPostRequestBuilder();
    }
    private okhttp3.Call usingJqlPostCall(SearchRequestBean searchRequestBean, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchRequestBean;

        // create path and map variables
        String localVarPath = "/rest/api/3/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usingJqlPostValidateBeforeCall(SearchRequestBean searchRequestBean, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'searchRequestBean' is set
        if (searchRequestBean == null) {
            throw new ApiException("Missing the required parameter 'searchRequestBean' when calling usingJqlPost(Async)");
        }

        return usingJqlPostCall(searchRequestBean, _callback);

    }


    private ApiResponse<SearchResults> usingJqlPostWithHttpInfo(SearchRequestBean searchRequestBean) throws ApiException {
        okhttp3.Call localVarCall = usingJqlPostValidateBeforeCall(searchRequestBean, null);
        Type localVarReturnType = new TypeToken<SearchResults>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call usingJqlPostAsync(SearchRequestBean searchRequestBean, final ApiCallback<SearchResults> _callback) throws ApiException {

        okhttp3.Call localVarCall = usingJqlPostValidateBeforeCall(searchRequestBean, _callback);
        Type localVarReturnType = new TypeToken<SearchResults>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UsingJqlPostRequestBuilder {
        private List<String> expand;
        private List<String> fields;
        private Boolean fieldsByKeys;
        private String jql;
        private Integer maxResults;
        private List<String> properties;
        private Integer startAt;
        private String validateQuery;

        private UsingJqlPostRequestBuilder() {
        }

        /**
         * Set expand
         * @param expand Use [expand](em&gt;#expansion) to include additional information about issues in the response. Note that, unlike the majority of instances where &#x60;expand&#x60; is specified, &#x60;expand&#x60; is defined as a list of values. The expand options are:   *  &#x60;renderedFields&#x60; Returns field values rendered in HTML format.  *  &#x60;names&#x60; Returns the display name of each field.  *  &#x60;schema&#x60; Returns the schema describing a field type.  *  &#x60;transitions&#x60; Returns all possible transitions for the issue.  *  &#x60;operations&#x60; Returns all possible operations for the issue.  *  &#x60;editmeta&#x60; Returns information about how each field can be edited.  *  &#x60;changelog&#x60; Returns a list of recent updates to an issue, sorted by date, starting from the most recent.  *  &#x60;versionedRepresentations&#x60; Instead of &#x60;fields&#x60;, returns &#x60;versionedRepresentations&#x60; a JSON array containing each version of a field&#39;s value, with the highest numbered item representing the most recent version. (optional)
         * @return UsingJqlPostRequestBuilder
         */
        public UsingJqlPostRequestBuilder expand(List<String> expand) {
            this.expand = expand;
            return this;
        }
        
        /**
         * Set fields
         * @param fields A list of fields to return for each issue, use it to retrieve a subset of fields. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;*all&#x60; Returns all fields.  *  &#x60;*navigable&#x60; Returns navigable fields.  *  Any issue field, prefixed with a minus to exclude.  The default is &#x60;*navigable&#x60;.  Examples:   *  &#x60;summary,comment&#x60; Returns the summary and comments fields only.  *  &#x60;-description&#x60; Returns all navigable (default) fields except description.  *  &#x60;*all,-comment&#x60; Returns all fields except comments.  Multiple &#x60;fields&#x60; parameters can be included in a request.  Note: All navigable fields are returned by default. This differs from [GET issue](https://dac-static.atlassian.com) where the default is all fields. (optional)
         * @return UsingJqlPostRequestBuilder
         */
        public UsingJqlPostRequestBuilder fields(List<String> fields) {
            this.fields = fields;
            return this;
        }
        
        /**
         * Set fieldsByKeys
         * @param fieldsByKeys Reference fields by their key (rather than ID). The default is &#x60;false&#x60;. (optional)
         * @return UsingJqlPostRequestBuilder
         */
        public UsingJqlPostRequestBuilder fieldsByKeys(Boolean fieldsByKeys) {
            this.fieldsByKeys = fieldsByKeys;
            return this;
        }
        
        /**
         * Set jql
         * @param jql A [JQL](https://confluence.atlassian.com/x/egORLQ) expression. (optional)
         * @return UsingJqlPostRequestBuilder
         */
        public UsingJqlPostRequestBuilder jql(String jql) {
            this.jql = jql;
            return this;
        }
        
        /**
         * Set maxResults
         * @param maxResults The maximum number of items to return per page. (optional, default to 50)
         * @return UsingJqlPostRequestBuilder
         */
        public UsingJqlPostRequestBuilder maxResults(Integer maxResults) {
            this.maxResults = maxResults;
            return this;
        }
        
        /**
         * Set properties
         * @param properties A list of up to 5 issue properties to include in the results. This parameter accepts a comma-separated list. (optional)
         * @return UsingJqlPostRequestBuilder
         */
        public UsingJqlPostRequestBuilder properties(List<String> properties) {
            this.properties = properties;
            return this;
        }
        
        /**
         * Set startAt
         * @param startAt The index of the first item to return in the page of results (page offset). The base index is &#x60;0&#x60;. (optional)
         * @return UsingJqlPostRequestBuilder
         */
        public UsingJqlPostRequestBuilder startAt(Integer startAt) {
            this.startAt = startAt;
            return this;
        }
        
        /**
         * Set validateQuery
         * @param validateQuery Determines how to validate the JQL query and treat the validation results. Supported values:   *  &#x60;strict&#x60; Returns a 400 response code if any errors are found, along with a list of all errors (and warnings).  *  &#x60;warn&#x60; Returns all errors as warnings.  *  &#x60;none&#x60; No validation is performed.  *  &#x60;true&#x60; *Deprecated* A legacy synonym for &#x60;strict&#x60;.  *  &#x60;false&#x60; *Deprecated* A legacy synonym for &#x60;warn&#x60;.  The default is &#x60;strict&#x60;.  Note: If the JQL is not correctly formed a 400 response code is returned, regardless of the &#x60;validateQuery&#x60; value. (optional)
         * @return UsingJqlPostRequestBuilder
         */
        public UsingJqlPostRequestBuilder validateQuery(String validateQuery) {
            this.validateQuery = validateQuery;
            return this;
        }
        
        /**
         * Build call for usingJqlPost
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the JQL query is invalid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SearchRequestBean searchRequestBean = buildBodyParams();
            return usingJqlPostCall(searchRequestBean, _callback);
        }

        private SearchRequestBean buildBodyParams() {
            SearchRequestBean searchRequestBean = new SearchRequestBean();
            searchRequestBean.expand(this.expand);
            searchRequestBean.fields(this.fields);
            searchRequestBean.fieldsByKeys(this.fieldsByKeys);
            searchRequestBean.jql(this.jql);
            searchRequestBean.maxResults(this.maxResults);
            searchRequestBean.properties(this.properties);
            searchRequestBean.startAt(this.startAt);
            if (this.validateQuery != null)
            searchRequestBean.validateQuery(SearchRequestBean.ValidateQueryEnum.fromValue(this.validateQuery));
            return searchRequestBean;
        }

        /**
         * Execute usingJqlPost request
         * @return SearchResults
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the JQL query is invalid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public SearchResults execute() throws ApiException {
            SearchRequestBean searchRequestBean = buildBodyParams();
            ApiResponse<SearchResults> localVarResp = usingJqlPostWithHttpInfo(searchRequestBean);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute usingJqlPost request with HTTP info returned
         * @return ApiResponse&lt;SearchResults&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the JQL query is invalid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<SearchResults> executeWithHttpInfo() throws ApiException {
            SearchRequestBean searchRequestBean = buildBodyParams();
            return usingJqlPostWithHttpInfo(searchRequestBean);
        }

        /**
         * Execute usingJqlPost request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the JQL query is invalid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<SearchResults> _callback) throws ApiException {
            SearchRequestBean searchRequestBean = buildBodyParams();
            return usingJqlPostAsync(searchRequestBean, _callback);
        }
    }

    /**
     * Search for issues using JQL (POST)
     * Searches for issues using [JQL](https://confluence.atlassian.com/x/egORLQ).  There is a [GET](https://dac-static.atlassian.com) version of this resource that can be used for smaller JQL query expressions.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:** Issues are included in the response where the user has:   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * @param searchRequestBean A JSON object containing the search request. (required)
     * @return UsingJqlPostRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if the JQL query is invalid. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
     </table>
     */
    public UsingJqlPostRequestBuilder usingJqlPost() throws IllegalArgumentException {
        return new UsingJqlPostRequestBuilder();
    }
}
