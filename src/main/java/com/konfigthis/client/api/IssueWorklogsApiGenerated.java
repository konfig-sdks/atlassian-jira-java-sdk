/*
 * The Jira Cloud platform REST API
 * Jira Cloud platform REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0-SNAPSHOT-9aad01a33a3dae75a5b6aedf98c77d2cbd2f865d
 * Contact: ecosystem@atlassian.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.ChangedWorklogs;
import com.konfigthis.client.model.EntityProperty;
import java.time.OffsetDateTime;
import com.konfigthis.client.model.PageOfWorklogs;
import java.net.URI;
import com.konfigthis.client.model.UserDetails;
import com.konfigthis.client.model.Visibility;
import com.konfigthis.client.model.Worklog;
import com.konfigthis.client.model.WorklogIdsRequestBean;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class IssueWorklogsApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public IssueWorklogsApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public IssueWorklogsApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call createWorklogCall(String issueIdOrKey, Map<String, Object> requestBody, Boolean notifyUsers, String adjustEstimate, String newEstimate, String reduceBy, String expand, Boolean overrideEditableFlag, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = requestBody;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/{issueIdOrKey}/worklog"
            .replace("{" + "issueIdOrKey" + "}", localVarApiClient.escapeString(issueIdOrKey.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (notifyUsers != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("notifyUsers", notifyUsers));
        }

        if (adjustEstimate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("adjustEstimate", adjustEstimate));
        }

        if (newEstimate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("newEstimate", newEstimate));
        }

        if (reduceBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("reduceBy", reduceBy));
        }

        if (expand != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expand", expand));
        }

        if (overrideEditableFlag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("overrideEditableFlag", overrideEditableFlag));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createWorklogValidateBeforeCall(String issueIdOrKey, Map<String, Object> requestBody, Boolean notifyUsers, String adjustEstimate, String newEstimate, String reduceBy, String expand, Boolean overrideEditableFlag, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueIdOrKey' is set
        if (issueIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'issueIdOrKey' when calling createWorklog(Async)");
        }

        // verify the required parameter 'requestBody' is set
        if (requestBody == null) {
            throw new ApiException("Missing the required parameter 'requestBody' when calling createWorklog(Async)");
        }

        return createWorklogCall(issueIdOrKey, requestBody, notifyUsers, adjustEstimate, newEstimate, reduceBy, expand, overrideEditableFlag, _callback);

    }


    private ApiResponse<Worklog> createWorklogWithHttpInfo(String issueIdOrKey, Map<String, Object> requestBody, Boolean notifyUsers, String adjustEstimate, String newEstimate, String reduceBy, String expand, Boolean overrideEditableFlag) throws ApiException {
        okhttp3.Call localVarCall = createWorklogValidateBeforeCall(issueIdOrKey, requestBody, notifyUsers, adjustEstimate, newEstimate, reduceBy, expand, overrideEditableFlag, null);
        Type localVarReturnType = new TypeToken<Worklog>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createWorklogAsync(String issueIdOrKey, Map<String, Object> requestBody, Boolean notifyUsers, String adjustEstimate, String newEstimate, String reduceBy, String expand, Boolean overrideEditableFlag, final ApiCallback<Worklog> _callback) throws ApiException {

        okhttp3.Call localVarCall = createWorklogValidateBeforeCall(issueIdOrKey, requestBody, notifyUsers, adjustEstimate, newEstimate, reduceBy, expand, overrideEditableFlag, _callback);
        Type localVarReturnType = new TypeToken<Worklog>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateWorklogRequestBuilder {
        private final String issueIdOrKey;
        private UserDetails author;
        private Object comment;
        private OffsetDateTime created;
        private String id;
        private String issueId;
        private List<EntityProperty> properties;
        private URI self;
        private OffsetDateTime started;
        private String timeSpent;
        private Long timeSpentSeconds;
        private UserDetails updateAuthor;
        private OffsetDateTime updated;
        private Visibility visibility;
        private Boolean notifyUsers;
        private String adjustEstimate;
        private String newEstimate;
        private String reduceBy;
        private String expand;
        private Boolean overrideEditableFlag;

        private CreateWorklogRequestBuilder(String issueIdOrKey) {
            this.issueIdOrKey = issueIdOrKey;
        }

        /**
         * Set author
         * @param author  (optional)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder author(UserDetails author) {
            this.author = author;
            return this;
        }
        
        /**
         * Set comment
         * @param comment A comment about the worklog in [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure/). Optional when creating or updating a worklog. (optional)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder comment(Object comment) {
            this.comment = comment;
            return this;
        }
        
        /**
         * Set created
         * @param created The datetime on which the worklog was created. (optional)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder created(OffsetDateTime created) {
            this.created = created;
            return this;
        }
        
        /**
         * Set id
         * @param id The ID of the worklog record. (optional)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder id(String id) {
            this.id = id;
            return this;
        }
        
        /**
         * Set issueId
         * @param issueId The ID of the issue this worklog is for. (optional)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder issueId(String issueId) {
            this.issueId = issueId;
            return this;
        }
        
        /**
         * Set properties
         * @param properties Details of properties for the worklog. Optional when creating or updating a worklog. (optional)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder properties(List<EntityProperty> properties) {
            this.properties = properties;
            return this;
        }
        
        /**
         * Set self
         * @param self The URL of the worklog item. (optional)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder self(URI self) {
            this.self = self;
            return this;
        }
        
        /**
         * Set started
         * @param started The datetime on which the worklog effort was started. Required when creating a worklog. Optional when updating a worklog. (optional)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder started(OffsetDateTime started) {
            this.started = started;
            return this;
        }
        
        /**
         * Set timeSpent
         * @param timeSpent The time spent working on the issue as days (\\\\#d), hours (\\\\#h), or minutes (\\\\#m or \\\\#). Required when creating a worklog if &#x60;timeSpentSeconds&#x60; isn&#39;t provided. Optional when updating a worklog. Cannot be provided if &#x60;timeSpentSecond&#x60; is provided. (optional)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder timeSpent(String timeSpent) {
            this.timeSpent = timeSpent;
            return this;
        }
        
        /**
         * Set timeSpentSeconds
         * @param timeSpentSeconds The time in seconds spent working on the issue. Required when creating a worklog if &#x60;timeSpent&#x60; isn&#39;t provided. Optional when updating a worklog. Cannot be provided if &#x60;timeSpent&#x60; is provided. (optional)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder timeSpentSeconds(Long timeSpentSeconds) {
            this.timeSpentSeconds = timeSpentSeconds;
            return this;
        }
        
        /**
         * Set updateAuthor
         * @param updateAuthor  (optional)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder updateAuthor(UserDetails updateAuthor) {
            this.updateAuthor = updateAuthor;
            return this;
        }
        
        /**
         * Set updated
         * @param updated The datetime on which the worklog was last updated. (optional)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder updated(OffsetDateTime updated) {
            this.updated = updated;
            return this;
        }
        
        /**
         * Set visibility
         * @param visibility  (optional)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder visibility(Visibility visibility) {
            this.visibility = visibility;
            return this;
        }
        
        /**
         * Set notifyUsers
         * @param notifyUsers Whether users watching the issue are notified by email. (optional, default to true)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder notifyUsers(Boolean notifyUsers) {
            this.notifyUsers = notifyUsers;
            return this;
        }
        
        /**
         * Set adjustEstimate
         * @param adjustEstimate Defines how to update the issue&#39;s time estimate, the options are:   *  &#x60;new&#x60; Sets the estimate to a specific value, defined in &#x60;newEstimate&#x60;.  *  &#x60;leave&#x60; Leaves the estimate unchanged.  *  &#x60;manual&#x60; Reduces the estimate by amount specified in &#x60;reduceBy&#x60;.  *  &#x60;auto&#x60; Reduces the estimate by the value of &#x60;timeSpent&#x60; in the worklog. (optional, default to auto)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder adjustEstimate(String adjustEstimate) {
            this.adjustEstimate = adjustEstimate;
            return this;
        }
        
        /**
         * Set newEstimate
         * @param newEstimate The value to set as the issue&#39;s remaining time estimate, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when &#x60;adjustEstimate&#x60; is &#x60;new&#x60;. (optional)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder newEstimate(String newEstimate) {
            this.newEstimate = newEstimate;
            return this;
        }
        
        /**
         * Set reduceBy
         * @param reduceBy The amount to reduce the issue&#39;s remaining estimate by, as days (\\#d), hours (\\#h), or minutes (\\#m). For example, *2d*. Required when &#x60;adjustEstimate&#x60; is &#x60;manual&#x60;. (optional)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder reduceBy(String reduceBy) {
            this.reduceBy = reduceBy;
            return this;
        }
        
        /**
         * Set expand
         * @param expand Use [expand](https://dac-static.atlassian.com) to include additional information about work logs in the response. This parameter accepts &#x60;properties&#x60;, which returns worklog properties. (optional, default to )
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder expand(String expand) {
            this.expand = expand;
            return this;
        }
        
        /**
         * Set overrideEditableFlag
         * @param overrideEditableFlag Whether the worklog entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) can use this flag. (optional, default to false)
         * @return CreateWorklogRequestBuilder
         */
        public CreateWorklogRequestBuilder overrideEditableFlag(Boolean overrideEditableFlag) {
            this.overrideEditableFlag = overrideEditableFlag;
            return this;
        }
        
        /**
         * Build call for createWorklog
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  &#x60;adjustEstimate&#x60; is set to &#x60;new&#x60; but &#x60;newEstimate&#x60; is not provided or is invalid.  *  &#x60;adjustEstimate&#x60; is set to &#x60;manual&#x60; but &#x60;reduceBy&#x60; is not provided or is invalid.  *  the user does not have permission to add the worklog.  *  the request JSON is malformed. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return createWorklogCall(issueIdOrKey, requestBody, notifyUsers, adjustEstimate, newEstimate, reduceBy, expand, overrideEditableFlag, _callback);
        }

        private Map<String, Object> buildBodyParams() {
            Map<String, Object> requestBody = new HashMap<String, Object>();
            requestBody.put("author", this.author);
            requestBody.put("comment", this.comment);
            requestBody.put("created", this.created);
            requestBody.put("id", this.id);
            requestBody.put("issueId", this.issueId);
            requestBody.put("properties", this.properties);
            requestBody.put("self", this.self);
            requestBody.put("started", this.started);
            requestBody.put("timeSpent", this.timeSpent);
            requestBody.put("timeSpentSeconds", this.timeSpentSeconds);
            requestBody.put("updateAuthor", this.updateAuthor);
            requestBody.put("updated", this.updated);
            requestBody.put("visibility", this.visibility);
            return requestBody;
        }

        /**
         * Execute createWorklog request
         * @return Worklog
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  &#x60;adjustEstimate&#x60; is set to &#x60;new&#x60; but &#x60;newEstimate&#x60; is not provided or is invalid.  *  &#x60;adjustEstimate&#x60; is set to &#x60;manual&#x60; but &#x60;reduceBy&#x60; is not provided or is invalid.  *  the user does not have permission to add the worklog.  *  the request JSON is malformed. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public Worklog execute() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            ApiResponse<Worklog> localVarResp = createWorklogWithHttpInfo(issueIdOrKey, requestBody, notifyUsers, adjustEstimate, newEstimate, reduceBy, expand, overrideEditableFlag);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createWorklog request with HTTP info returned
         * @return ApiResponse&lt;Worklog&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  &#x60;adjustEstimate&#x60; is set to &#x60;new&#x60; but &#x60;newEstimate&#x60; is not provided or is invalid.  *  &#x60;adjustEstimate&#x60; is set to &#x60;manual&#x60; but &#x60;reduceBy&#x60; is not provided or is invalid.  *  the user does not have permission to add the worklog.  *  the request JSON is malformed. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Worklog> executeWithHttpInfo() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return createWorklogWithHttpInfo(issueIdOrKey, requestBody, notifyUsers, adjustEstimate, newEstimate, reduceBy, expand, overrideEditableFlag);
        }

        /**
         * Execute createWorklog request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  &#x60;adjustEstimate&#x60; is set to &#x60;new&#x60; but &#x60;newEstimate&#x60; is not provided or is invalid.  *  &#x60;adjustEstimate&#x60; is set to &#x60;manual&#x60; but &#x60;reduceBy&#x60; is not provided or is invalid.  *  the user does not have permission to add the worklog.  *  the request JSON is malformed. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Worklog> _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return createWorklogAsync(issueIdOrKey, requestBody, notifyUsers, adjustEstimate, newEstimate, reduceBy, expand, overrideEditableFlag, _callback);
        }
    }

    /**
     * Add worklog
     * Adds a worklog to an issue.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:**   *  *Browse projects* and *Work on issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * @param issueIdOrKey The ID or key the issue. (required)
     * @param requestBody  (required)
     * @return CreateWorklogRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if:   *  &#x60;adjustEstimate&#x60; is set to &#x60;new&#x60; but &#x60;newEstimate&#x60; is not provided or is invalid.  *  &#x60;adjustEstimate&#x60; is set to &#x60;manual&#x60; but &#x60;reduceBy&#x60; is not provided or is invalid.  *  the user does not have permission to add the worklog.  *  the request JSON is malformed. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
     </table>
     */
    public CreateWorklogRequestBuilder createWorklog(String issueIdOrKey) throws IllegalArgumentException {
        if (issueIdOrKey == null) throw new IllegalArgumentException("\"issueIdOrKey\" is required but got null");
            

        return new CreateWorklogRequestBuilder(issueIdOrKey);
    }
    private okhttp3.Call deleteWorklogByIdCall(String issueIdOrKey, String id, Boolean notifyUsers, String adjustEstimate, String newEstimate, String increaseBy, Boolean overrideEditableFlag, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/{issueIdOrKey}/worklog/{id}"
            .replace("{" + "issueIdOrKey" + "}", localVarApiClient.escapeString(issueIdOrKey.toString()))
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (notifyUsers != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("notifyUsers", notifyUsers));
        }

        if (adjustEstimate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("adjustEstimate", adjustEstimate));
        }

        if (newEstimate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("newEstimate", newEstimate));
        }

        if (increaseBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("increaseBy", increaseBy));
        }

        if (overrideEditableFlag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("overrideEditableFlag", overrideEditableFlag));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteWorklogByIdValidateBeforeCall(String issueIdOrKey, String id, Boolean notifyUsers, String adjustEstimate, String newEstimate, String increaseBy, Boolean overrideEditableFlag, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueIdOrKey' is set
        if (issueIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'issueIdOrKey' when calling deleteWorklogById(Async)");
        }

        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling deleteWorklogById(Async)");
        }

        return deleteWorklogByIdCall(issueIdOrKey, id, notifyUsers, adjustEstimate, newEstimate, increaseBy, overrideEditableFlag, _callback);

    }


    private ApiResponse<Void> deleteWorklogByIdWithHttpInfo(String issueIdOrKey, String id, Boolean notifyUsers, String adjustEstimate, String newEstimate, String increaseBy, Boolean overrideEditableFlag) throws ApiException {
        okhttp3.Call localVarCall = deleteWorklogByIdValidateBeforeCall(issueIdOrKey, id, notifyUsers, adjustEstimate, newEstimate, increaseBy, overrideEditableFlag, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteWorklogByIdAsync(String issueIdOrKey, String id, Boolean notifyUsers, String adjustEstimate, String newEstimate, String increaseBy, Boolean overrideEditableFlag, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteWorklogByIdValidateBeforeCall(issueIdOrKey, id, notifyUsers, adjustEstimate, newEstimate, increaseBy, overrideEditableFlag, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteWorklogByIdRequestBuilder {
        private final String issueIdOrKey;
        private final String id;
        private Boolean notifyUsers;
        private String adjustEstimate;
        private String newEstimate;
        private String increaseBy;
        private Boolean overrideEditableFlag;

        private DeleteWorklogByIdRequestBuilder(String issueIdOrKey, String id) {
            this.issueIdOrKey = issueIdOrKey;
            this.id = id;
        }

        /**
         * Set notifyUsers
         * @param notifyUsers Whether users watching the issue are notified by email. (optional, default to true)
         * @return DeleteWorklogByIdRequestBuilder
         */
        public DeleteWorklogByIdRequestBuilder notifyUsers(Boolean notifyUsers) {
            this.notifyUsers = notifyUsers;
            return this;
        }
        
        /**
         * Set adjustEstimate
         * @param adjustEstimate Defines how to update the issue&#39;s time estimate, the options are:   *  &#x60;new&#x60; Sets the estimate to a specific value, defined in &#x60;newEstimate&#x60;.  *  &#x60;leave&#x60; Leaves the estimate unchanged.  *  &#x60;manual&#x60; Increases the estimate by amount specified in &#x60;increaseBy&#x60;.  *  &#x60;auto&#x60; Reduces the estimate by the value of &#x60;timeSpent&#x60; in the worklog. (optional, default to auto)
         * @return DeleteWorklogByIdRequestBuilder
         */
        public DeleteWorklogByIdRequestBuilder adjustEstimate(String adjustEstimate) {
            this.adjustEstimate = adjustEstimate;
            return this;
        }
        
        /**
         * Set newEstimate
         * @param newEstimate The value to set as the issue&#39;s remaining time estimate, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when &#x60;adjustEstimate&#x60; is &#x60;new&#x60;. (optional)
         * @return DeleteWorklogByIdRequestBuilder
         */
        public DeleteWorklogByIdRequestBuilder newEstimate(String newEstimate) {
            this.newEstimate = newEstimate;
            return this;
        }
        
        /**
         * Set increaseBy
         * @param increaseBy The amount to increase the issue&#39;s remaining estimate by, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when &#x60;adjustEstimate&#x60; is &#x60;manual&#x60;. (optional)
         * @return DeleteWorklogByIdRequestBuilder
         */
        public DeleteWorklogByIdRequestBuilder increaseBy(String increaseBy) {
            this.increaseBy = increaseBy;
            return this;
        }
        
        /**
         * Set overrideEditableFlag
         * @param overrideEditableFlag Whether the work log entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with admin permission can use this flag. (optional, default to false)
         * @return DeleteWorklogByIdRequestBuilder
         */
        public DeleteWorklogByIdRequestBuilder overrideEditableFlag(Boolean overrideEditableFlag) {
            this.overrideEditableFlag = overrideEditableFlag;
            return this;
        }
        
        /**
         * Build call for deleteWorklogById
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  &#x60;adjustEstimate&#x60; is set to &#x60;new&#x60; but &#x60;newEstimate&#x60; is not provided or is invalid.  *  &#x60;adjustEstimate&#x60; is set to &#x60;manual&#x60; but &#x60;reduceBy&#x60; is not provided or is invalid.  *  the user does not have permission to delete the worklog. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or user does not have permission to view the issue.  *  the worklog is not found or the user does not have permission to view it.  *  time tracking is disabled. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteWorklogByIdCall(issueIdOrKey, id, notifyUsers, adjustEstimate, newEstimate, increaseBy, overrideEditableFlag, _callback);
        }


        /**
         * Execute deleteWorklogById request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  &#x60;adjustEstimate&#x60; is set to &#x60;new&#x60; but &#x60;newEstimate&#x60; is not provided or is invalid.  *  &#x60;adjustEstimate&#x60; is set to &#x60;manual&#x60; but &#x60;reduceBy&#x60; is not provided or is invalid.  *  the user does not have permission to delete the worklog. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or user does not have permission to view the issue.  *  the worklog is not found or the user does not have permission to view it.  *  time tracking is disabled. </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deleteWorklogByIdWithHttpInfo(issueIdOrKey, id, notifyUsers, adjustEstimate, newEstimate, increaseBy, overrideEditableFlag);
        }

        /**
         * Execute deleteWorklogById request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  &#x60;adjustEstimate&#x60; is set to &#x60;new&#x60; but &#x60;newEstimate&#x60; is not provided or is invalid.  *  &#x60;adjustEstimate&#x60; is set to &#x60;manual&#x60; but &#x60;reduceBy&#x60; is not provided or is invalid.  *  the user does not have permission to delete the worklog. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or user does not have permission to view the issue.  *  the worklog is not found or the user does not have permission to view it.  *  time tracking is disabled. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deleteWorklogByIdWithHttpInfo(issueIdOrKey, id, notifyUsers, adjustEstimate, newEstimate, increaseBy, overrideEditableFlag);
        }

        /**
         * Execute deleteWorklogById request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  &#x60;adjustEstimate&#x60; is set to &#x60;new&#x60; but &#x60;newEstimate&#x60; is not provided or is invalid.  *  &#x60;adjustEstimate&#x60; is set to &#x60;manual&#x60; but &#x60;reduceBy&#x60; is not provided or is invalid.  *  the user does not have permission to delete the worklog. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or user does not have permission to view the issue.  *  the worklog is not found or the user does not have permission to view it.  *  time tracking is disabled. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deleteWorklogByIdAsync(issueIdOrKey, id, notifyUsers, adjustEstimate, newEstimate, increaseBy, overrideEditableFlag, _callback);
        }
    }

    /**
     * Delete worklog
     * Deletes a worklog from an issue.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  *Delete all worklogs*[project permission](https://confluence.atlassian.com/x/yodKLg) to delete any worklog or *Delete own worklogs* to delete worklogs created by the user,  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.
     * @param issueIdOrKey The ID or key of the issue. (required)
     * @param id The ID of the worklog. (required)
     * @return DeleteWorklogByIdRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if:   *  &#x60;adjustEstimate&#x60; is set to &#x60;new&#x60; but &#x60;newEstimate&#x60; is not provided or is invalid.  *  &#x60;adjustEstimate&#x60; is set to &#x60;manual&#x60; but &#x60;reduceBy&#x60; is not provided or is invalid.  *  the user does not have permission to delete the worklog. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Returned if:   *  the issue is not found or user does not have permission to view the issue.  *  the worklog is not found or the user does not have permission to view it.  *  time tracking is disabled. </td><td>  -  </td></tr>
     </table>
     */
    public DeleteWorklogByIdRequestBuilder deleteWorklogById(String issueIdOrKey, String id) throws IllegalArgumentException {
        if (issueIdOrKey == null) throw new IllegalArgumentException("\"issueIdOrKey\" is required but got null");
            

        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
            

        return new DeleteWorklogByIdRequestBuilder(issueIdOrKey, id);
    }
    private okhttp3.Call getDetailsForListCall(String issueIdOrKey, Long startAt, Integer maxResults, Long startedAfter, Long startedBefore, String expand, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/{issueIdOrKey}/worklog"
            .replace("{" + "issueIdOrKey" + "}", localVarApiClient.escapeString(issueIdOrKey.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (startAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startAt", startAt));
        }

        if (maxResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxResults", maxResults));
        }

        if (startedAfter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startedAfter", startedAfter));
        }

        if (startedBefore != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startedBefore", startedBefore));
        }

        if (expand != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expand", expand));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getDetailsForListValidateBeforeCall(String issueIdOrKey, Long startAt, Integer maxResults, Long startedAfter, Long startedBefore, String expand, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueIdOrKey' is set
        if (issueIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'issueIdOrKey' when calling getDetailsForList(Async)");
        }

        return getDetailsForListCall(issueIdOrKey, startAt, maxResults, startedAfter, startedBefore, expand, _callback);

    }


    private ApiResponse<PageOfWorklogs> getDetailsForListWithHttpInfo(String issueIdOrKey, Long startAt, Integer maxResults, Long startedAfter, Long startedBefore, String expand) throws ApiException {
        okhttp3.Call localVarCall = getDetailsForListValidateBeforeCall(issueIdOrKey, startAt, maxResults, startedAfter, startedBefore, expand, null);
        Type localVarReturnType = new TypeToken<PageOfWorklogs>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getDetailsForListAsync(String issueIdOrKey, Long startAt, Integer maxResults, Long startedAfter, Long startedBefore, String expand, final ApiCallback<PageOfWorklogs> _callback) throws ApiException {

        okhttp3.Call localVarCall = getDetailsForListValidateBeforeCall(issueIdOrKey, startAt, maxResults, startedAfter, startedBefore, expand, _callback);
        Type localVarReturnType = new TypeToken<PageOfWorklogs>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetDetailsForListRequestBuilder {
        private final String issueIdOrKey;
        private Long startAt;
        private Integer maxResults;
        private Long startedAfter;
        private Long startedBefore;
        private String expand;

        private GetDetailsForListRequestBuilder(String issueIdOrKey) {
            this.issueIdOrKey = issueIdOrKey;
        }

        /**
         * Set startAt
         * @param startAt The index of the first item to return in a page of results (page offset). (optional, default to 0)
         * @return GetDetailsForListRequestBuilder
         */
        public GetDetailsForListRequestBuilder startAt(Long startAt) {
            this.startAt = startAt;
            return this;
        }
        
        /**
         * Set maxResults
         * @param maxResults The maximum number of items to return per page. (optional, default to 5000)
         * @return GetDetailsForListRequestBuilder
         */
        public GetDetailsForListRequestBuilder maxResults(Integer maxResults) {
            this.maxResults = maxResults;
            return this;
        }
        
        /**
         * Set startedAfter
         * @param startedAfter The worklog start date and time, as a UNIX timestamp in milliseconds, after which worklogs are returned. (optional)
         * @return GetDetailsForListRequestBuilder
         */
        public GetDetailsForListRequestBuilder startedAfter(Long startedAfter) {
            this.startedAfter = startedAfter;
            return this;
        }
        
        /**
         * Set startedBefore
         * @param startedBefore The worklog start date and time, as a UNIX timestamp in milliseconds, before which worklogs are returned. (optional)
         * @return GetDetailsForListRequestBuilder
         */
        public GetDetailsForListRequestBuilder startedBefore(Long startedBefore) {
            this.startedBefore = startedBefore;
            return this;
        }
        
        /**
         * Set expand
         * @param expand Use [expand](https://dac-static.atlassian.com) to include additional information about worklogs in the response. This parameter accepts&#x60;properties&#x60;, which returns worklog properties. (optional, default to )
         * @return GetDetailsForListRequestBuilder
         */
        public GetDetailsForListRequestBuilder expand(String expand) {
            this.expand = expand;
            return this;
        }
        
        /**
         * Build call for getDetailsForList
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or the user does not have permission to view the issue.  *  &#x60;startAt&#x60; or &#x60;maxResults&#x60; has non-numeric values.  *  time tracking is disabled. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getDetailsForListCall(issueIdOrKey, startAt, maxResults, startedAfter, startedBefore, expand, _callback);
        }


        /**
         * Execute getDetailsForList request
         * @return PageOfWorklogs
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or the user does not have permission to view the issue.  *  &#x60;startAt&#x60; or &#x60;maxResults&#x60; has non-numeric values.  *  time tracking is disabled. </td><td>  -  </td></tr>
         </table>
         */
        public PageOfWorklogs execute() throws ApiException {
            ApiResponse<PageOfWorklogs> localVarResp = getDetailsForListWithHttpInfo(issueIdOrKey, startAt, maxResults, startedAfter, startedBefore, expand);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getDetailsForList request with HTTP info returned
         * @return ApiResponse&lt;PageOfWorklogs&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or the user does not have permission to view the issue.  *  &#x60;startAt&#x60; or &#x60;maxResults&#x60; has non-numeric values.  *  time tracking is disabled. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<PageOfWorklogs> executeWithHttpInfo() throws ApiException {
            return getDetailsForListWithHttpInfo(issueIdOrKey, startAt, maxResults, startedAfter, startedBefore, expand);
        }

        /**
         * Execute getDetailsForList request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or the user does not have permission to view the issue.  *  &#x60;startAt&#x60; or &#x60;maxResults&#x60; has non-numeric values.  *  time tracking is disabled. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<PageOfWorklogs> _callback) throws ApiException {
            return getDetailsForListAsync(issueIdOrKey, startAt, maxResults, startedAfter, startedBefore, expand, _callback);
        }
    }

    /**
     * Get issue worklogs
     * Returns worklogs for an issue, starting from the oldest worklog or from the worklog started on or after a date and time.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:** Workloads are only returned where the user has:   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.
     * @param issueIdOrKey The ID or key of the issue. (required)
     * @return GetDetailsForListRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Returned if:   *  the issue is not found or the user does not have permission to view the issue.  *  &#x60;startAt&#x60; or &#x60;maxResults&#x60; has non-numeric values.  *  time tracking is disabled. </td><td>  -  </td></tr>
     </table>
     */
    public GetDetailsForListRequestBuilder getDetailsForList(String issueIdOrKey) throws IllegalArgumentException {
        if (issueIdOrKey == null) throw new IllegalArgumentException("\"issueIdOrKey\" is required but got null");
            

        return new GetDetailsForListRequestBuilder(issueIdOrKey);
    }
    private okhttp3.Call getUpdatedWorklogIdsCall(Long since, String expand, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/worklog/updated";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (since != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("since", since));
        }

        if (expand != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expand", expand));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUpdatedWorklogIdsValidateBeforeCall(Long since, String expand, final ApiCallback _callback) throws ApiException {
        return getUpdatedWorklogIdsCall(since, expand, _callback);

    }


    private ApiResponse<ChangedWorklogs> getUpdatedWorklogIdsWithHttpInfo(Long since, String expand) throws ApiException {
        okhttp3.Call localVarCall = getUpdatedWorklogIdsValidateBeforeCall(since, expand, null);
        Type localVarReturnType = new TypeToken<ChangedWorklogs>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUpdatedWorklogIdsAsync(Long since, String expand, final ApiCallback<ChangedWorklogs> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUpdatedWorklogIdsValidateBeforeCall(since, expand, _callback);
        Type localVarReturnType = new TypeToken<ChangedWorklogs>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetUpdatedWorklogIdsRequestBuilder {
        private Long since;
        private String expand;

        private GetUpdatedWorklogIdsRequestBuilder() {
        }

        /**
         * Set since
         * @param since The date and time, as a UNIX timestamp in milliseconds, after which updated worklogs are returned. (optional, default to 0)
         * @return GetUpdatedWorklogIdsRequestBuilder
         */
        public GetUpdatedWorklogIdsRequestBuilder since(Long since) {
            this.since = since;
            return this;
        }
        
        /**
         * Set expand
         * @param expand Use [expand](https://dac-static.atlassian.com) to include additional information about worklogs in the response. This parameter accepts &#x60;properties&#x60; that returns the properties of each worklog. (optional, default to )
         * @return GetUpdatedWorklogIdsRequestBuilder
         */
        public GetUpdatedWorklogIdsRequestBuilder expand(String expand) {
            this.expand = expand;
            return this;
        }
        
        /**
         * Build call for getUpdatedWorklogIds
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUpdatedWorklogIdsCall(since, expand, _callback);
        }


        /**
         * Execute getUpdatedWorklogIds request
         * @return ChangedWorklogs
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public ChangedWorklogs execute() throws ApiException {
            ApiResponse<ChangedWorklogs> localVarResp = getUpdatedWorklogIdsWithHttpInfo(since, expand);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUpdatedWorklogIds request with HTTP info returned
         * @return ApiResponse&lt;ChangedWorklogs&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ChangedWorklogs> executeWithHttpInfo() throws ApiException {
            return getUpdatedWorklogIdsWithHttpInfo(since, expand);
        }

        /**
         * Execute getUpdatedWorklogIds request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ChangedWorklogs> _callback) throws ApiException {
            return getUpdatedWorklogIdsAsync(since, expand, _callback);
        }
    }

    /**
     * Get IDs of updated worklogs
     * Returns a list of IDs and update timestamps for worklogs updated after a date and time.  This resource is paginated, with a limit of 1000 worklogs per page. Each page lists worklogs from oldest to youngest. If the number of items in the date range exceeds 1000, &#x60;until&#x60; indicates the timestamp of the youngest item on the page. Also, &#x60;nextPage&#x60; provides the URL for the next page of worklogs. The &#x60;lastPage&#x60; parameter is set to true on the last page of worklogs.  This resource does not return worklogs updated during the minute preceding the request.  **[Permissions](https://dac-static.atlassian.com) required:** Permission to access Jira, however, worklogs are only returned where either of the following is true:   *  the worklog is set as *Viewable by All Users*.  *  the user is a member of a project role or group with permission to view the worklog.
     * @return GetUpdatedWorklogIdsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
     </table>
     */
    public GetUpdatedWorklogIdsRequestBuilder getUpdatedWorklogIds() throws IllegalArgumentException {
        return new GetUpdatedWorklogIdsRequestBuilder();
    }
    private okhttp3.Call getWorklogDetailsCall(String issueIdOrKey, String id, String expand, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/{issueIdOrKey}/worklog/{id}"
            .replace("{" + "issueIdOrKey" + "}", localVarApiClient.escapeString(issueIdOrKey.toString()))
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (expand != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expand", expand));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getWorklogDetailsValidateBeforeCall(String issueIdOrKey, String id, String expand, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueIdOrKey' is set
        if (issueIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'issueIdOrKey' when calling getWorklogDetails(Async)");
        }

        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getWorklogDetails(Async)");
        }

        return getWorklogDetailsCall(issueIdOrKey, id, expand, _callback);

    }


    private ApiResponse<Worklog> getWorklogDetailsWithHttpInfo(String issueIdOrKey, String id, String expand) throws ApiException {
        okhttp3.Call localVarCall = getWorklogDetailsValidateBeforeCall(issueIdOrKey, id, expand, null);
        Type localVarReturnType = new TypeToken<Worklog>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getWorklogDetailsAsync(String issueIdOrKey, String id, String expand, final ApiCallback<Worklog> _callback) throws ApiException {

        okhttp3.Call localVarCall = getWorklogDetailsValidateBeforeCall(issueIdOrKey, id, expand, _callback);
        Type localVarReturnType = new TypeToken<Worklog>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetWorklogDetailsRequestBuilder {
        private final String issueIdOrKey;
        private final String id;
        private String expand;

        private GetWorklogDetailsRequestBuilder(String issueIdOrKey, String id) {
            this.issueIdOrKey = issueIdOrKey;
            this.id = id;
        }

        /**
         * Set expand
         * @param expand Use [expand](https://dac-static.atlassian.com) to include additional information about work logs in the response. This parameter accepts  &#x60;properties&#x60;, which returns worklog properties. (optional, default to )
         * @return GetWorklogDetailsRequestBuilder
         */
        public GetWorklogDetailsRequestBuilder expand(String expand) {
            this.expand = expand;
            return this;
        }
        
        /**
         * Build call for getWorklogDetails
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or the user does not have permission to view it.  *  the worklog is not found or the user does not have permission to view it.  *  time tracking is disabled.  . </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getWorklogDetailsCall(issueIdOrKey, id, expand, _callback);
        }


        /**
         * Execute getWorklogDetails request
         * @return Worklog
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or the user does not have permission to view it.  *  the worklog is not found or the user does not have permission to view it.  *  time tracking is disabled.  . </td><td>  -  </td></tr>
         </table>
         */
        public Worklog execute() throws ApiException {
            ApiResponse<Worklog> localVarResp = getWorklogDetailsWithHttpInfo(issueIdOrKey, id, expand);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getWorklogDetails request with HTTP info returned
         * @return ApiResponse&lt;Worklog&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or the user does not have permission to view it.  *  the worklog is not found or the user does not have permission to view it.  *  time tracking is disabled.  . </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Worklog> executeWithHttpInfo() throws ApiException {
            return getWorklogDetailsWithHttpInfo(issueIdOrKey, id, expand);
        }

        /**
         * Execute getWorklogDetails request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or the user does not have permission to view it.  *  the worklog is not found or the user does not have permission to view it.  *  time tracking is disabled.  . </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Worklog> _callback) throws ApiException {
            return getWorklogDetailsAsync(issueIdOrKey, id, expand, _callback);
        }
    }

    /**
     * Get worklog
     * Returns a worklog.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.
     * @param issueIdOrKey The ID or key of the issue. (required)
     * @param id The ID of the worklog. (required)
     * @return GetWorklogDetailsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Returned if:   *  the issue is not found or the user does not have permission to view it.  *  the worklog is not found or the user does not have permission to view it.  *  time tracking is disabled.  . </td><td>  -  </td></tr>
     </table>
     */
    public GetWorklogDetailsRequestBuilder getWorklogDetails(String issueIdOrKey, String id) throws IllegalArgumentException {
        if (issueIdOrKey == null) throw new IllegalArgumentException("\"issueIdOrKey\" is required but got null");
            

        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
            

        return new GetWorklogDetailsRequestBuilder(issueIdOrKey, id);
    }
    private okhttp3.Call getWorklogDetailsForListCall(WorklogIdsRequestBean worklogIdsRequestBean, String expand, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = worklogIdsRequestBean;

        // create path and map variables
        String localVarPath = "/rest/api/3/worklog/list";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (expand != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expand", expand));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getWorklogDetailsForListValidateBeforeCall(WorklogIdsRequestBean worklogIdsRequestBean, String expand, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'worklogIdsRequestBean' is set
        if (worklogIdsRequestBean == null) {
            throw new ApiException("Missing the required parameter 'worklogIdsRequestBean' when calling getWorklogDetailsForList(Async)");
        }

        return getWorklogDetailsForListCall(worklogIdsRequestBean, expand, _callback);

    }


    private ApiResponse<List<Worklog>> getWorklogDetailsForListWithHttpInfo(WorklogIdsRequestBean worklogIdsRequestBean, String expand) throws ApiException {
        okhttp3.Call localVarCall = getWorklogDetailsForListValidateBeforeCall(worklogIdsRequestBean, expand, null);
        Type localVarReturnType = new TypeToken<List<Worklog>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getWorklogDetailsForListAsync(WorklogIdsRequestBean worklogIdsRequestBean, String expand, final ApiCallback<List<Worklog>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getWorklogDetailsForListValidateBeforeCall(worklogIdsRequestBean, expand, _callback);
        Type localVarReturnType = new TypeToken<List<Worklog>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetWorklogDetailsForListRequestBuilder {
        private final Set<Long> ids;
        private String expand;

        private GetWorklogDetailsForListRequestBuilder(Set<Long> ids) {
            this.ids = ids;
        }

        /**
         * Set expand
         * @param expand Use [expand](https://dac-static.atlassian.com) to include additional information about worklogs in the response. This parameter accepts &#x60;properties&#x60; that returns the properties of each worklog. (optional, default to )
         * @return GetWorklogDetailsForListRequestBuilder
         */
        public GetWorklogDetailsForListRequestBuilder expand(String expand) {
            this.expand = expand;
            return this;
        }
        
        /**
         * Build call for getWorklogDetailsForList
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the request contains more than 1000 worklog IDs or is empty. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            WorklogIdsRequestBean worklogIdsRequestBean = buildBodyParams();
            return getWorklogDetailsForListCall(worklogIdsRequestBean, expand, _callback);
        }

        private WorklogIdsRequestBean buildBodyParams() {
            WorklogIdsRequestBean worklogIdsRequestBean = new WorklogIdsRequestBean();
            worklogIdsRequestBean.ids(this.ids);
            return worklogIdsRequestBean;
        }

        /**
         * Execute getWorklogDetailsForList request
         * @return List&lt;Worklog&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the request contains more than 1000 worklog IDs or is empty. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public List<Worklog> execute() throws ApiException {
            WorklogIdsRequestBean worklogIdsRequestBean = buildBodyParams();
            ApiResponse<List<Worklog>> localVarResp = getWorklogDetailsForListWithHttpInfo(worklogIdsRequestBean, expand);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getWorklogDetailsForList request with HTTP info returned
         * @return ApiResponse&lt;List&lt;Worklog&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the request contains more than 1000 worklog IDs or is empty. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<Worklog>> executeWithHttpInfo() throws ApiException {
            WorklogIdsRequestBean worklogIdsRequestBean = buildBodyParams();
            return getWorklogDetailsForListWithHttpInfo(worklogIdsRequestBean, expand);
        }

        /**
         * Execute getWorklogDetailsForList request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the request contains more than 1000 worklog IDs or is empty. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<Worklog>> _callback) throws ApiException {
            WorklogIdsRequestBean worklogIdsRequestBean = buildBodyParams();
            return getWorklogDetailsForListAsync(worklogIdsRequestBean, expand, _callback);
        }
    }

    /**
     * Get worklogs
     * Returns worklog details for a list of worklog IDs.  The returned list of worklogs is limited to 1000 items.  **[Permissions](https://dac-static.atlassian.com) required:** Permission to access Jira, however, worklogs are only returned where either of the following is true:   *  the worklog is set as *Viewable by All Users*.  *  the user is a member of a project role or group with permission to view the worklog.
     * @param worklogIdsRequestBean A JSON object containing a list of worklog IDs. (required)
     * @return GetWorklogDetailsForListRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if the request contains more than 1000 worklog IDs or is empty. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
     </table>
     */
    public GetWorklogDetailsForListRequestBuilder getWorklogDetailsForList(Set<Long> ids) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
        return new GetWorklogDetailsForListRequestBuilder(ids);
    }
    private okhttp3.Call listDeletedWorklogIdsCall(Long since, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/worklog/deleted";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (since != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("since", since));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listDeletedWorklogIdsValidateBeforeCall(Long since, final ApiCallback _callback) throws ApiException {
        return listDeletedWorklogIdsCall(since, _callback);

    }


    private ApiResponse<ChangedWorklogs> listDeletedWorklogIdsWithHttpInfo(Long since) throws ApiException {
        okhttp3.Call localVarCall = listDeletedWorklogIdsValidateBeforeCall(since, null);
        Type localVarReturnType = new TypeToken<ChangedWorklogs>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listDeletedWorklogIdsAsync(Long since, final ApiCallback<ChangedWorklogs> _callback) throws ApiException {

        okhttp3.Call localVarCall = listDeletedWorklogIdsValidateBeforeCall(since, _callback);
        Type localVarReturnType = new TypeToken<ChangedWorklogs>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListDeletedWorklogIdsRequestBuilder {
        private Long since;

        private ListDeletedWorklogIdsRequestBuilder() {
        }

        /**
         * Set since
         * @param since The date and time, as a UNIX timestamp in milliseconds, after which deleted worklogs are returned. (optional, default to 0)
         * @return ListDeletedWorklogIdsRequestBuilder
         */
        public ListDeletedWorklogIdsRequestBuilder since(Long since) {
            this.since = since;
            return this;
        }
        
        /**
         * Build call for listDeletedWorklogIds
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listDeletedWorklogIdsCall(since, _callback);
        }


        /**
         * Execute listDeletedWorklogIds request
         * @return ChangedWorklogs
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public ChangedWorklogs execute() throws ApiException {
            ApiResponse<ChangedWorklogs> localVarResp = listDeletedWorklogIdsWithHttpInfo(since);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listDeletedWorklogIds request with HTTP info returned
         * @return ApiResponse&lt;ChangedWorklogs&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ChangedWorklogs> executeWithHttpInfo() throws ApiException {
            return listDeletedWorklogIdsWithHttpInfo(since);
        }

        /**
         * Execute listDeletedWorklogIds request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ChangedWorklogs> _callback) throws ApiException {
            return listDeletedWorklogIdsAsync(since, _callback);
        }
    }

    /**
     * Get IDs of deleted worklogs
     * Returns a list of IDs and delete timestamps for worklogs deleted after a date and time.  This resource is paginated, with a limit of 1000 worklogs per page. Each page lists worklogs from oldest to youngest. If the number of items in the date range exceeds 1000, &#x60;until&#x60; indicates the timestamp of the youngest item on the page. Also, &#x60;nextPage&#x60; provides the URL for the next page of worklogs. The &#x60;lastPage&#x60; parameter is set to true on the last page of worklogs.  This resource does not return worklogs deleted during the minute preceding the request.  **[Permissions](https://dac-static.atlassian.com) required:** Permission to access Jira.
     * @return ListDeletedWorklogIdsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
     </table>
     */
    public ListDeletedWorklogIdsRequestBuilder listDeletedWorklogIds() throws IllegalArgumentException {
        return new ListDeletedWorklogIdsRequestBuilder();
    }
    private okhttp3.Call updateWorklogCall(String issueIdOrKey, String id, Map<String, Object> requestBody, Boolean notifyUsers, String adjustEstimate, String newEstimate, String expand, Boolean overrideEditableFlag, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = requestBody;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/{issueIdOrKey}/worklog/{id}"
            .replace("{" + "issueIdOrKey" + "}", localVarApiClient.escapeString(issueIdOrKey.toString()))
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (notifyUsers != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("notifyUsers", notifyUsers));
        }

        if (adjustEstimate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("adjustEstimate", adjustEstimate));
        }

        if (newEstimate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("newEstimate", newEstimate));
        }

        if (expand != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expand", expand));
        }

        if (overrideEditableFlag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("overrideEditableFlag", overrideEditableFlag));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateWorklogValidateBeforeCall(String issueIdOrKey, String id, Map<String, Object> requestBody, Boolean notifyUsers, String adjustEstimate, String newEstimate, String expand, Boolean overrideEditableFlag, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueIdOrKey' is set
        if (issueIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'issueIdOrKey' when calling updateWorklog(Async)");
        }

        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling updateWorklog(Async)");
        }

        // verify the required parameter 'requestBody' is set
        if (requestBody == null) {
            throw new ApiException("Missing the required parameter 'requestBody' when calling updateWorklog(Async)");
        }

        return updateWorklogCall(issueIdOrKey, id, requestBody, notifyUsers, adjustEstimate, newEstimate, expand, overrideEditableFlag, _callback);

    }


    private ApiResponse<Worklog> updateWorklogWithHttpInfo(String issueIdOrKey, String id, Map<String, Object> requestBody, Boolean notifyUsers, String adjustEstimate, String newEstimate, String expand, Boolean overrideEditableFlag) throws ApiException {
        okhttp3.Call localVarCall = updateWorklogValidateBeforeCall(issueIdOrKey, id, requestBody, notifyUsers, adjustEstimate, newEstimate, expand, overrideEditableFlag, null);
        Type localVarReturnType = new TypeToken<Worklog>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateWorklogAsync(String issueIdOrKey, String id, Map<String, Object> requestBody, Boolean notifyUsers, String adjustEstimate, String newEstimate, String expand, Boolean overrideEditableFlag, final ApiCallback<Worklog> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateWorklogValidateBeforeCall(issueIdOrKey, id, requestBody, notifyUsers, adjustEstimate, newEstimate, expand, overrideEditableFlag, _callback);
        Type localVarReturnType = new TypeToken<Worklog>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UpdateWorklogRequestBuilder {
        private final String issueIdOrKey;
        private final String id;
        private UserDetails author;
        private Object comment;
        private OffsetDateTime created;
        private String id;
        private String issueId;
        private List<EntityProperty> properties;
        private URI self;
        private OffsetDateTime started;
        private String timeSpent;
        private Long timeSpentSeconds;
        private UserDetails updateAuthor;
        private OffsetDateTime updated;
        private Visibility visibility;
        private Boolean notifyUsers;
        private String adjustEstimate;
        private String newEstimate;
        private String expand;
        private Boolean overrideEditableFlag;

        private UpdateWorklogRequestBuilder(String issueIdOrKey, String id) {
            this.issueIdOrKey = issueIdOrKey;
            this.id = id;
        }

        /**
         * Set author
         * @param author  (optional)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder author(UserDetails author) {
            this.author = author;
            return this;
        }
        
        /**
         * Set comment
         * @param comment A comment about the worklog in [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure/). Optional when creating or updating a worklog. (optional)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder comment(Object comment) {
            this.comment = comment;
            return this;
        }
        
        /**
         * Set created
         * @param created The datetime on which the worklog was created. (optional)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder created(OffsetDateTime created) {
            this.created = created;
            return this;
        }
        
        /**
         * Set id
         * @param id The ID of the worklog record. (optional)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder id(String id) {
            this.id = id;
            return this;
        }
        
        /**
         * Set issueId
         * @param issueId The ID of the issue this worklog is for. (optional)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder issueId(String issueId) {
            this.issueId = issueId;
            return this;
        }
        
        /**
         * Set properties
         * @param properties Details of properties for the worklog. Optional when creating or updating a worklog. (optional)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder properties(List<EntityProperty> properties) {
            this.properties = properties;
            return this;
        }
        
        /**
         * Set self
         * @param self The URL of the worklog item. (optional)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder self(URI self) {
            this.self = self;
            return this;
        }
        
        /**
         * Set started
         * @param started The datetime on which the worklog effort was started. Required when creating a worklog. Optional when updating a worklog. (optional)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder started(OffsetDateTime started) {
            this.started = started;
            return this;
        }
        
        /**
         * Set timeSpent
         * @param timeSpent The time spent working on the issue as days (\\\\#d), hours (\\\\#h), or minutes (\\\\#m or \\\\#). Required when creating a worklog if &#x60;timeSpentSeconds&#x60; isn&#39;t provided. Optional when updating a worklog. Cannot be provided if &#x60;timeSpentSecond&#x60; is provided. (optional)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder timeSpent(String timeSpent) {
            this.timeSpent = timeSpent;
            return this;
        }
        
        /**
         * Set timeSpentSeconds
         * @param timeSpentSeconds The time in seconds spent working on the issue. Required when creating a worklog if &#x60;timeSpent&#x60; isn&#39;t provided. Optional when updating a worklog. Cannot be provided if &#x60;timeSpent&#x60; is provided. (optional)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder timeSpentSeconds(Long timeSpentSeconds) {
            this.timeSpentSeconds = timeSpentSeconds;
            return this;
        }
        
        /**
         * Set updateAuthor
         * @param updateAuthor  (optional)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder updateAuthor(UserDetails updateAuthor) {
            this.updateAuthor = updateAuthor;
            return this;
        }
        
        /**
         * Set updated
         * @param updated The datetime on which the worklog was last updated. (optional)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder updated(OffsetDateTime updated) {
            this.updated = updated;
            return this;
        }
        
        /**
         * Set visibility
         * @param visibility  (optional)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder visibility(Visibility visibility) {
            this.visibility = visibility;
            return this;
        }
        
        /**
         * Set notifyUsers
         * @param notifyUsers Whether users watching the issue are notified by email. (optional, default to true)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder notifyUsers(Boolean notifyUsers) {
            this.notifyUsers = notifyUsers;
            return this;
        }
        
        /**
         * Set adjustEstimate
         * @param adjustEstimate Defines how to update the issue&#39;s time estimate, the options are:   *  &#x60;new&#x60; Sets the estimate to a specific value, defined in &#x60;newEstimate&#x60;.  *  &#x60;leave&#x60; Leaves the estimate unchanged.  *  &#x60;auto&#x60; Updates the estimate by the difference between the original and updated value of &#x60;timeSpent&#x60; or &#x60;timeSpentSeconds&#x60;. (optional, default to auto)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder adjustEstimate(String adjustEstimate) {
            this.adjustEstimate = adjustEstimate;
            return this;
        }
        
        /**
         * Set newEstimate
         * @param newEstimate The value to set as the issue&#39;s remaining time estimate, as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). For example, *2d*. Required when &#x60;adjustEstimate&#x60; is &#x60;new&#x60;. (optional)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder newEstimate(String newEstimate) {
            this.newEstimate = newEstimate;
            return this;
        }
        
        /**
         * Set expand
         * @param expand Use [expand](https://dac-static.atlassian.com) to include additional information about worklogs in the response. This parameter accepts &#x60;properties&#x60;, which returns worklog properties. (optional, default to )
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder expand(String expand) {
            this.expand = expand;
            return this;
        }
        
        /**
         * Set overrideEditableFlag
         * @param overrideEditableFlag Whether the worklog should be added to the issue even if the issue is not editable. For example, because the issue is closed. Connect and Forge app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) can use this flag. (optional, default to false)
         * @return UpdateWorklogRequestBuilder
         */
        public UpdateWorklogRequestBuilder overrideEditableFlag(Boolean overrideEditableFlag) {
            this.overrideEditableFlag = overrideEditableFlag;
            return this;
        }
        
        /**
         * Build call for updateWorklog
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  &#x60;adjustEstimate&#x60; is set to &#x60;new&#x60; but &#x60;newEstimate&#x60; is not provided or is invalid.  *  the user does not have permission to update the worklog.  *  the request JSON is malformed. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or user does not have permission to view the issue.  *  the worklog is not found or the user does not have permission to view it.  *  time tracking is disabled. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return updateWorklogCall(issueIdOrKey, id, requestBody, notifyUsers, adjustEstimate, newEstimate, expand, overrideEditableFlag, _callback);
        }

        private Map<String, Object> buildBodyParams() {
            Map<String, Object> requestBody = new HashMap<String, Object>();
            requestBody.put("author", this.author);
            requestBody.put("comment", this.comment);
            requestBody.put("created", this.created);
            requestBody.put("id", this.id);
            requestBody.put("issueId", this.issueId);
            requestBody.put("properties", this.properties);
            requestBody.put("self", this.self);
            requestBody.put("started", this.started);
            requestBody.put("timeSpent", this.timeSpent);
            requestBody.put("timeSpentSeconds", this.timeSpentSeconds);
            requestBody.put("updateAuthor", this.updateAuthor);
            requestBody.put("updated", this.updated);
            requestBody.put("visibility", this.visibility);
            return requestBody;
        }

        /**
         * Execute updateWorklog request
         * @return Worklog
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  &#x60;adjustEstimate&#x60; is set to &#x60;new&#x60; but &#x60;newEstimate&#x60; is not provided or is invalid.  *  the user does not have permission to update the worklog.  *  the request JSON is malformed. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or user does not have permission to view the issue.  *  the worklog is not found or the user does not have permission to view it.  *  time tracking is disabled. </td><td>  -  </td></tr>
         </table>
         */
        public Worklog execute() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            ApiResponse<Worklog> localVarResp = updateWorklogWithHttpInfo(issueIdOrKey, id, requestBody, notifyUsers, adjustEstimate, newEstimate, expand, overrideEditableFlag);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute updateWorklog request with HTTP info returned
         * @return ApiResponse&lt;Worklog&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  &#x60;adjustEstimate&#x60; is set to &#x60;new&#x60; but &#x60;newEstimate&#x60; is not provided or is invalid.  *  the user does not have permission to update the worklog.  *  the request JSON is malformed. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or user does not have permission to view the issue.  *  the worklog is not found or the user does not have permission to view it.  *  time tracking is disabled. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Worklog> executeWithHttpInfo() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return updateWorklogWithHttpInfo(issueIdOrKey, id, requestBody, notifyUsers, adjustEstimate, newEstimate, expand, overrideEditableFlag);
        }

        /**
         * Execute updateWorklog request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  &#x60;adjustEstimate&#x60; is set to &#x60;new&#x60; but &#x60;newEstimate&#x60; is not provided or is invalid.  *  the user does not have permission to update the worklog.  *  the request JSON is malformed. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if:   *  the issue is not found or user does not have permission to view the issue.  *  the worklog is not found or the user does not have permission to view it.  *  time tracking is disabled. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Worklog> _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return updateWorklogAsync(issueIdOrKey, id, requestBody, notifyUsers, adjustEstimate, newEstimate, expand, overrideEditableFlag, _callback);
        }
    }

    /**
     * Update worklog
     * Updates a worklog.  Time tracking must be enabled in Jira, otherwise this operation returns an error. For more information, see [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  *  *Edit all worklogs*[project permission](https://confluence.atlassian.com/x/yodKLg) to update any worklog or *Edit own worklogs* to update worklogs created by the user.  *  If the worklog has visibility restrictions, belongs to the group or has the role visibility is restricted to.
     * @param issueIdOrKey The ID or key the issue. (required)
     * @param id The ID of the worklog. (required)
     * @param requestBody  (required)
     * @return UpdateWorklogRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if:   *  &#x60;adjustEstimate&#x60; is set to &#x60;new&#x60; but &#x60;newEstimate&#x60; is not provided or is invalid.  *  the user does not have permission to update the worklog.  *  the request JSON is malformed. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Returned if:   *  the issue is not found or user does not have permission to view the issue.  *  the worklog is not found or the user does not have permission to view it.  *  time tracking is disabled. </td><td>  -  </td></tr>
     </table>
     */
    public UpdateWorklogRequestBuilder updateWorklog(String issueIdOrKey, String id) throws IllegalArgumentException {
        if (issueIdOrKey == null) throw new IllegalArgumentException("\"issueIdOrKey\" is required but got null");
            

        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
            

        return new UpdateWorklogRequestBuilder(issueIdOrKey, id);
    }
}
