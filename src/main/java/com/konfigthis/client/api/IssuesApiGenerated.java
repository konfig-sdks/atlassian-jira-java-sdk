/*
 * The Jira Cloud platform REST API
 * Jira Cloud platform REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0-SNAPSHOT-9aad01a33a3dae75a5b6aedf98c77d2cbd2f865d
 * Contact: ecosystem@atlassian.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.ArchiveIssueAsyncRequest;
import com.konfigthis.client.model.ArchivedIssuesFilterRequest;
import com.konfigthis.client.model.AvatarUrlsBean;
import com.konfigthis.client.model.CreatedIssue;
import com.konfigthis.client.model.CreatedIssues;
import com.konfigthis.client.model.DateRangeFilterRequest;
import com.konfigthis.client.model.EntityProperty;
import com.konfigthis.client.model.ExportArchivedIssuesTaskProgressResponse;
import com.konfigthis.client.model.HistoryMetadata;
import com.konfigthis.client.model.IssueArchivalSyncRequest;
import com.konfigthis.client.model.IssueArchivalSyncResponse;
import com.konfigthis.client.model.IssueBean;
import com.konfigthis.client.model.IssueChangelogIds;
import com.konfigthis.client.model.IssueCreateMetadata;
import com.konfigthis.client.model.IssueEvent;
import com.konfigthis.client.model.IssueTransition;
import com.konfigthis.client.model.IssueUpdateDetails;
import com.konfigthis.client.model.IssueUpdateMetadata;
import com.konfigthis.client.model.IssuesUpdateBean;
import com.konfigthis.client.model.Notification;
import com.konfigthis.client.model.NotificationRecipients;
import com.konfigthis.client.model.NotificationRecipientsRestrictions;
import com.konfigthis.client.model.PageBeanChangelog;
import com.konfigthis.client.model.PageOfChangelogs;
import com.konfigthis.client.model.PageOfCreateMetaIssueTypeWithField;
import com.konfigthis.client.model.PageOfCreateMetaIssueTypes;
import com.konfigthis.client.model.SimpleListWrapperApplicationRole;
import com.konfigthis.client.model.SimpleListWrapperGroupName;
import com.konfigthis.client.model.Transitions;
import java.net.URI;
import com.konfigthis.client.model.User;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class IssuesApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public IssuesApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public IssuesApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call archiveByIdsPutCall(IssueArchivalSyncRequest issueArchivalSyncRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = issueArchivalSyncRequest;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/archive";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call archiveByIdsPutValidateBeforeCall(IssueArchivalSyncRequest issueArchivalSyncRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueArchivalSyncRequest' is set
        if (issueArchivalSyncRequest == null) {
            throw new ApiException("Missing the required parameter 'issueArchivalSyncRequest' when calling archiveByIdsPut(Async)");
        }

        return archiveByIdsPutCall(issueArchivalSyncRequest, _callback);

    }


    private ApiResponse<IssueArchivalSyncResponse> archiveByIdsPutWithHttpInfo(IssueArchivalSyncRequest issueArchivalSyncRequest) throws ApiException {
        okhttp3.Call localVarCall = archiveByIdsPutValidateBeforeCall(issueArchivalSyncRequest, null);
        Type localVarReturnType = new TypeToken<IssueArchivalSyncResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call archiveByIdsPutAsync(IssueArchivalSyncRequest issueArchivalSyncRequest, final ApiCallback<IssueArchivalSyncResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = archiveByIdsPutValidateBeforeCall(issueArchivalSyncRequest, _callback);
        Type localVarReturnType = new TypeToken<IssueArchivalSyncResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ArchiveByIdsPutRequestBuilder {
        private List<String> issueIdsOrKeys;

        private ArchiveByIdsPutRequestBuilder() {
        }

        /**
         * Set issueIdsOrKeys
         * @param issueIdsOrKeys  (optional)
         * @return ArchiveByIdsPutRequestBuilder
         */
        public ArchiveByIdsPutRequestBuilder issueIdsOrKeys(List<String> issueIdsOrKeys) {
            this.issueIdsOrKeys = issueIdsOrKeys;
            return this;
        }
        
        /**
         * Build call for archiveByIdsPut
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if there is at least one valid issue to archive in the request. The return message will include the count of archived issues and subtasks, as well as error details for issues which failed to get archived. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            IssueArchivalSyncRequest issueArchivalSyncRequest = buildBodyParams();
            return archiveByIdsPutCall(issueArchivalSyncRequest, _callback);
        }

        private IssueArchivalSyncRequest buildBodyParams() {
            IssueArchivalSyncRequest issueArchivalSyncRequest = new IssueArchivalSyncRequest();
            issueArchivalSyncRequest.issueIdsOrKeys(this.issueIdsOrKeys);
            return issueArchivalSyncRequest;
        }

        /**
         * Execute archiveByIdsPut request
         * @return IssueArchivalSyncResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if there is at least one valid issue to archive in the request. The return message will include the count of archived issues and subtasks, as well as error details for issues which failed to get archived. </td><td>  -  </td></tr>
         </table>
         */
        public IssueArchivalSyncResponse execute() throws ApiException {
            IssueArchivalSyncRequest issueArchivalSyncRequest = buildBodyParams();
            ApiResponse<IssueArchivalSyncResponse> localVarResp = archiveByIdsPutWithHttpInfo(issueArchivalSyncRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute archiveByIdsPut request with HTTP info returned
         * @return ApiResponse&lt;IssueArchivalSyncResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if there is at least one valid issue to archive in the request. The return message will include the count of archived issues and subtasks, as well as error details for issues which failed to get archived. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<IssueArchivalSyncResponse> executeWithHttpInfo() throws ApiException {
            IssueArchivalSyncRequest issueArchivalSyncRequest = buildBodyParams();
            return archiveByIdsPutWithHttpInfo(issueArchivalSyncRequest);
        }

        /**
         * Execute archiveByIdsPut request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if there is at least one valid issue to archive in the request. The return message will include the count of archived issues and subtasks, as well as error details for issues which failed to get archived. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<IssueArchivalSyncResponse> _callback) throws ApiException {
            IssueArchivalSyncRequest issueArchivalSyncRequest = buildBodyParams();
            return archiveByIdsPutAsync(issueArchivalSyncRequest, _callback);
        }
    }

    /**
     * Archive issue(s) by issue ID/key
     * Enables admins to archive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) archived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](https://dac-static.atlassian.com) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
     * @param issueArchivalSyncRequest Contains a list of issue keys or IDs to be archived. (required)
     * @return ArchiveByIdsPutRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if there is at least one valid issue to archive in the request. The return message will include the count of archived issues and subtasks, as well as error details for issues which failed to get archived. </td><td>  -  </td></tr>
     </table>
     */
    public ArchiveByIdsPutRequestBuilder archiveByIdsPut() throws IllegalArgumentException {
        return new ArchiveByIdsPutRequestBuilder();
    }
    private okhttp3.Call archiveByJqlPostCall(ArchiveIssueAsyncRequest archiveIssueAsyncRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = archiveIssueAsyncRequest;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/archive";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call archiveByJqlPostValidateBeforeCall(ArchiveIssueAsyncRequest archiveIssueAsyncRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'archiveIssueAsyncRequest' is set
        if (archiveIssueAsyncRequest == null) {
            throw new ApiException("Missing the required parameter 'archiveIssueAsyncRequest' when calling archiveByJqlPost(Async)");
        }

        return archiveByJqlPostCall(archiveIssueAsyncRequest, _callback);

    }


    private ApiResponse<String> archiveByJqlPostWithHttpInfo(ArchiveIssueAsyncRequest archiveIssueAsyncRequest) throws ApiException {
        okhttp3.Call localVarCall = archiveByJqlPostValidateBeforeCall(archiveIssueAsyncRequest, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call archiveByJqlPostAsync(ArchiveIssueAsyncRequest archiveIssueAsyncRequest, final ApiCallback<String> _callback) throws ApiException {

        okhttp3.Call localVarCall = archiveByJqlPostValidateBeforeCall(archiveIssueAsyncRequest, _callback);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ArchiveByJqlPostRequestBuilder {
        private String jql;

        private ArchiveByJqlPostRequestBuilder() {
        }

        /**
         * Set jql
         * @param jql  (optional)
         * @return ArchiveByJqlPostRequestBuilder
         */
        public ArchiveByJqlPostRequestBuilder jql(String jql) {
            this.jql = jql;
            return this;
        }
        
        /**
         * Build call for archiveByJqlPost
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> Returns the URL to check the status of the submitted request. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ArchiveIssueAsyncRequest archiveIssueAsyncRequest = buildBodyParams();
            return archiveByJqlPostCall(archiveIssueAsyncRequest, _callback);
        }

        private ArchiveIssueAsyncRequest buildBodyParams() {
            ArchiveIssueAsyncRequest archiveIssueAsyncRequest = new ArchiveIssueAsyncRequest();
            archiveIssueAsyncRequest.jql(this.jql);
            return archiveIssueAsyncRequest;
        }

        /**
         * Execute archiveByJqlPost request
         * @return String
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> Returns the URL to check the status of the submitted request. </td><td>  -  </td></tr>
         </table>
         */
        public String execute() throws ApiException {
            ArchiveIssueAsyncRequest archiveIssueAsyncRequest = buildBodyParams();
            ApiResponse<String> localVarResp = archiveByJqlPostWithHttpInfo(archiveIssueAsyncRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute archiveByJqlPost request with HTTP info returned
         * @return ApiResponse&lt;String&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> Returns the URL to check the status of the submitted request. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<String> executeWithHttpInfo() throws ApiException {
            ArchiveIssueAsyncRequest archiveIssueAsyncRequest = buildBodyParams();
            return archiveByJqlPostWithHttpInfo(archiveIssueAsyncRequest);
        }

        /**
         * Execute archiveByJqlPost request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> Returns the URL to check the status of the submitted request. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<String> _callback) throws ApiException {
            ArchiveIssueAsyncRequest archiveIssueAsyncRequest = buildBodyParams();
            return archiveByJqlPostAsync(archiveIssueAsyncRequest, _callback);
        }
    }

    /**
     * Archive issue(s) by JQL
     * Enables admins to archive up to 100,000 issues in a single request using JQL, returning the URL to check the status of the submitted request.  You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) and [cancel task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-cancel-post) APIs to manage the request.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](https://dac-static.atlassian.com) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request per jira instance can be active at any given time.     
     * @param archiveIssueAsyncRequest A JQL query specifying the issues to archive. Note that subtasks can only be archived through their parent issues. (required)
     * @return ArchiveByJqlPostRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns the URL to check the status of the submitted request. </td><td>  -  </td></tr>
     </table>
     */
    public ArchiveByJqlPostRequestBuilder archiveByJqlPost() throws IllegalArgumentException {
        return new ArchiveByJqlPostRequestBuilder();
    }
    private okhttp3.Call assignIssueToUserCall(String issueIdOrKey, User user, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = user;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/{issueIdOrKey}/assignee"
            .replace("{" + "issueIdOrKey" + "}", localVarApiClient.escapeString(issueIdOrKey.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call assignIssueToUserValidateBeforeCall(String issueIdOrKey, User user, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueIdOrKey' is set
        if (issueIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'issueIdOrKey' when calling assignIssueToUser(Async)");
        }

        // verify the required parameter 'user' is set
        if (user == null) {
            throw new ApiException("Missing the required parameter 'user' when calling assignIssueToUser(Async)");
        }

        return assignIssueToUserCall(issueIdOrKey, user, _callback);

    }


    private ApiResponse<Object> assignIssueToUserWithHttpInfo(String issueIdOrKey, User user) throws ApiException {
        okhttp3.Call localVarCall = assignIssueToUserValidateBeforeCall(issueIdOrKey, user, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call assignIssueToUserAsync(String issueIdOrKey, User user, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = assignIssueToUserValidateBeforeCall(issueIdOrKey, user, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class AssignIssueToUserRequestBuilder {
        private final String issueIdOrKey;
        private String accountId;
        private String accountType;
        private Boolean active;
        private SimpleListWrapperApplicationRole applicationRoles;
        private AvatarUrlsBean avatarUrls;
        private String displayName;
        private String emailAddress;
        private String expand;
        private SimpleListWrapperGroupName groups;
        private String key;
        private String locale;
        private String name;
        private URI self;
        private String timeZone;

        private AssignIssueToUserRequestBuilder(String issueIdOrKey) {
            this.issueIdOrKey = issueIdOrKey;
        }

        /**
         * Set accountId
         * @param accountId The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Required in requests. (optional)
         * @return AssignIssueToUserRequestBuilder
         */
        public AssignIssueToUserRequestBuilder accountId(String accountId) {
            this.accountId = accountId;
            return this;
        }
        
        /**
         * Set accountType
         * @param accountType The user account type. Can take the following values:   *  &#x60;atlassian&#x60; regular Atlassian user account  *  &#x60;app&#x60; system account used for Connect applications and OAuth to represent external systems  *  &#x60;customer&#x60; Jira Service Desk account representing an external service desk (optional)
         * @return AssignIssueToUserRequestBuilder
         */
        public AssignIssueToUserRequestBuilder accountType(String accountType) {
            this.accountType = accountType;
            return this;
        }
        
        /**
         * Set active
         * @param active Whether the user is active. (optional)
         * @return AssignIssueToUserRequestBuilder
         */
        public AssignIssueToUserRequestBuilder active(Boolean active) {
            this.active = active;
            return this;
        }
        
        /**
         * Set applicationRoles
         * @param applicationRoles The application roles the user is assigned to. (optional)
         * @return AssignIssueToUserRequestBuilder
         */
        public AssignIssueToUserRequestBuilder applicationRoles(SimpleListWrapperApplicationRole applicationRoles) {
            this.applicationRoles = applicationRoles;
            return this;
        }
        
        /**
         * Set avatarUrls
         * @param avatarUrls The avatars of the user. (optional)
         * @return AssignIssueToUserRequestBuilder
         */
        public AssignIssueToUserRequestBuilder avatarUrls(AvatarUrlsBean avatarUrls) {
            this.avatarUrls = avatarUrls;
            return this;
        }
        
        /**
         * Set displayName
         * @param displayName The display name of the user. Depending on the user’s privacy setting, this may return an alternative value. (optional)
         * @return AssignIssueToUserRequestBuilder
         */
        public AssignIssueToUserRequestBuilder displayName(String displayName) {
            this.displayName = displayName;
            return this;
        }
        
        /**
         * Set emailAddress
         * @param emailAddress The email address of the user. Depending on the user’s privacy setting, this may be returned as null. (optional)
         * @return AssignIssueToUserRequestBuilder
         */
        public AssignIssueToUserRequestBuilder emailAddress(String emailAddress) {
            this.emailAddress = emailAddress;
            return this;
        }
        
        /**
         * Set expand
         * @param expand Expand options that include additional user details in the response. (optional)
         * @return AssignIssueToUserRequestBuilder
         */
        public AssignIssueToUserRequestBuilder expand(String expand) {
            this.expand = expand;
            return this;
        }
        
        /**
         * Set groups
         * @param groups The groups that the user belongs to. (optional)
         * @return AssignIssueToUserRequestBuilder
         */
        public AssignIssueToUserRequestBuilder groups(SimpleListWrapperGroupName groups) {
            this.groups = groups;
            return this;
        }
        
        /**
         * Set key
         * @param key This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. (optional)
         * @return AssignIssueToUserRequestBuilder
         */
        public AssignIssueToUserRequestBuilder key(String key) {
            this.key = key;
            return this;
        }
        
        /**
         * Set locale
         * @param locale The locale of the user. Depending on the user’s privacy setting, this may be returned as null. (optional)
         * @return AssignIssueToUserRequestBuilder
         */
        public AssignIssueToUserRequestBuilder locale(String locale) {
            this.locale = locale;
            return this;
        }
        
        /**
         * Set name
         * @param name This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. (optional)
         * @return AssignIssueToUserRequestBuilder
         */
        public AssignIssueToUserRequestBuilder name(String name) {
            this.name = name;
            return this;
        }
        
        /**
         * Set self
         * @param self The URL of the user. (optional)
         * @return AssignIssueToUserRequestBuilder
         */
        public AssignIssueToUserRequestBuilder self(URI self) {
            this.self = self;
            return this;
        }
        
        /**
         * Set timeZone
         * @param timeZone The time zone specified in the user&#39;s profile. Depending on the user’s privacy setting, this may be returned as null. (optional)
         * @return AssignIssueToUserRequestBuilder
         */
        public AssignIssueToUserRequestBuilder timeZone(String timeZone) {
            this.timeZone = timeZone;
            return this;
        }
        
        /**
         * Build call for assignIssueToUser
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  the user is not found.  *  &#x60;name&#x60;, &#x60;key&#x60;, or &#x60;accountId&#x60; is missing.  *  more than one of &#x60;name&#x60;, &#x60;key&#x60;, and &#x60;accountId&#x60; are provided. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user does not have the necessary permission. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            User user = buildBodyParams();
            return assignIssueToUserCall(issueIdOrKey, user, _callback);
        }

        private User buildBodyParams() {
            User user = new User();
            user.accountId(this.accountId);
            if (this.accountType != null)
            user.accountType(User.AccountTypeEnum.fromValue(this.accountType));
            user.active(this.active);
            user.applicationRoles(this.applicationRoles);
            user.avatarUrls(this.avatarUrls);
            user.displayName(this.displayName);
            user.emailAddress(this.emailAddress);
            user.expand(this.expand);
            user.groups(this.groups);
            user.key(this.key);
            user.locale(this.locale);
            user.name(this.name);
            user.self(this.self);
            user.timeZone(this.timeZone);
            return user;
        }

        /**
         * Execute assignIssueToUser request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  the user is not found.  *  &#x60;name&#x60;, &#x60;key&#x60;, or &#x60;accountId&#x60; is missing.  *  more than one of &#x60;name&#x60;, &#x60;key&#x60;, and &#x60;accountId&#x60; are provided. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user does not have the necessary permission. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found. </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            User user = buildBodyParams();
            ApiResponse<Object> localVarResp = assignIssueToUserWithHttpInfo(issueIdOrKey, user);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute assignIssueToUser request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  the user is not found.  *  &#x60;name&#x60;, &#x60;key&#x60;, or &#x60;accountId&#x60; is missing.  *  more than one of &#x60;name&#x60;, &#x60;key&#x60;, and &#x60;accountId&#x60; are provided. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user does not have the necessary permission. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            User user = buildBodyParams();
            return assignIssueToUserWithHttpInfo(issueIdOrKey, user);
        }

        /**
         * Execute assignIssueToUser request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  the user is not found.  *  &#x60;name&#x60;, &#x60;key&#x60;, or &#x60;accountId&#x60; is missing.  *  more than one of &#x60;name&#x60;, &#x60;key&#x60;, and &#x60;accountId&#x60; are provided. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user does not have the necessary permission. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            User user = buildBodyParams();
            return assignIssueToUserAsync(issueIdOrKey, user, _callback);
        }
    }

    /**
     * Assign issue
     * Assigns an issue to a user. Use this operation when the calling user does not have the *Edit Issues* permission but has the *Assign issue* permission for the project that the issue is in.  If &#x60;name&#x60; or &#x60;accountId&#x60; is set to:   *  &#x60;\&quot;-1\&quot;&#x60;, the issue is assigned to the default assignee for the project.  *  &#x60;null&#x60;, the issue is set to unassigned.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:**   *  *Browse Projects* and *Assign Issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * @param issueIdOrKey The ID or key of the issue to be assigned. (required)
     * @param user The request object with the user that the issue is assigned to. (required)
     * @return AssignIssueToUserRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if:   *  the user is not found.  *  &#x60;name&#x60;, &#x60;key&#x60;, or &#x60;accountId&#x60; is missing.  *  more than one of &#x60;name&#x60;, &#x60;key&#x60;, and &#x60;accountId&#x60; are provided. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Returned if the user does not have the necessary permission. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Returned if the issue is not found. </td><td>  -  </td></tr>
     </table>
     */
    public AssignIssueToUserRequestBuilder assignIssueToUser(String issueIdOrKey) throws IllegalArgumentException {
        if (issueIdOrKey == null) throw new IllegalArgumentException("\"issueIdOrKey\" is required but got null");
            

        return new AssignIssueToUserRequestBuilder(issueIdOrKey);
    }
    private okhttp3.Call bulkCreateIssueCall(Map<String, Object> requestBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = requestBody;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/bulk";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call bulkCreateIssueValidateBeforeCall(Map<String, Object> requestBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'requestBody' is set
        if (requestBody == null) {
            throw new ApiException("Missing the required parameter 'requestBody' when calling bulkCreateIssue(Async)");
        }

        return bulkCreateIssueCall(requestBody, _callback);

    }


    private ApiResponse<CreatedIssues> bulkCreateIssueWithHttpInfo(Map<String, Object> requestBody) throws ApiException {
        okhttp3.Call localVarCall = bulkCreateIssueValidateBeforeCall(requestBody, null);
        Type localVarReturnType = new TypeToken<CreatedIssues>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call bulkCreateIssueAsync(Map<String, Object> requestBody, final ApiCallback<CreatedIssues> _callback) throws ApiException {

        okhttp3.Call localVarCall = bulkCreateIssueValidateBeforeCall(requestBody, _callback);
        Type localVarReturnType = new TypeToken<CreatedIssues>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class BulkCreateIssueRequestBuilder {
        private List<IssueUpdateDetails> issueUpdates;

        private BulkCreateIssueRequestBuilder() {
        }

        /**
         * Set issueUpdates
         * @param issueUpdates  (optional)
         * @return BulkCreateIssueRequestBuilder
         */
        public BulkCreateIssueRequestBuilder issueUpdates(List<IssueUpdateDetails> issueUpdates) {
            this.issueUpdates = issueUpdates;
            return this;
        }
        
        /**
         * Build call for bulkCreateIssue
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Returned if any of the issue or subtask creation requests were successful. A request may be unsuccessful when it:   *  is missing required fields.  *  contains invalid field values.  *  contains fields that cannot be set for the issue type.  *  is by a user who does not have the necessary permission.  *  is to create a subtype in a project different that of the parent issue.  *  is for a subtask when the option to create subtasks is disabled.  *  is invalid for any other reason. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return bulkCreateIssueCall(requestBody, _callback);
        }

        private Map<String, Object> buildBodyParams() {
            Map<String, Object> requestBody = new HashMap<String, Object>();
            requestBody.put("issueUpdates", this.issueUpdates);
            return requestBody;
        }

        /**
         * Execute bulkCreateIssue request
         * @return CreatedIssues
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Returned if any of the issue or subtask creation requests were successful. A request may be unsuccessful when it:   *  is missing required fields.  *  contains invalid field values.  *  contains fields that cannot be set for the issue type.  *  is by a user who does not have the necessary permission.  *  is to create a subtype in a project different that of the parent issue.  *  is for a subtask when the option to create subtasks is disabled.  *  is invalid for any other reason. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public CreatedIssues execute() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            ApiResponse<CreatedIssues> localVarResp = bulkCreateIssueWithHttpInfo(requestBody);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute bulkCreateIssue request with HTTP info returned
         * @return ApiResponse&lt;CreatedIssues&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Returned if any of the issue or subtask creation requests were successful. A request may be unsuccessful when it:   *  is missing required fields.  *  contains invalid field values.  *  contains fields that cannot be set for the issue type.  *  is by a user who does not have the necessary permission.  *  is to create a subtype in a project different that of the parent issue.  *  is for a subtask when the option to create subtasks is disabled.  *  is invalid for any other reason. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<CreatedIssues> executeWithHttpInfo() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return bulkCreateIssueWithHttpInfo(requestBody);
        }

        /**
         * Execute bulkCreateIssue request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Returned if any of the issue or subtask creation requests were successful. A request may be unsuccessful when it:   *  is missing required fields.  *  contains invalid field values.  *  contains fields that cannot be set for the issue type.  *  is by a user who does not have the necessary permission.  *  is to create a subtype in a project different that of the parent issue.  *  is for a subtask when the option to create subtasks is disabled.  *  is invalid for any other reason. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<CreatedIssues> _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return bulkCreateIssueAsync(requestBody, _callback);
        }
    }

    /**
     * Bulk create issue
     * Creates upto **50** issues and, where the option to create subtasks is enabled in Jira, subtasks. Transitions may be applied, to move the issues or subtasks to a workflow step other than the default start step, and issue properties set.  The content of each issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [Get create issue metadata](https://dac-static.atlassian.com). These are the same fields that appear on the issues&#39; create screens. Note that the &#x60;description&#x60;, &#x60;environment&#x60;, and any &#x60;textarea&#x60; type custom fields (multi-line text fields) take Atlassian Document Format content. Single line custom fields (&#x60;textfield&#x60;) accept a string and don&#39;t handle Atlassian Document Format content.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [Get create issue metadata](https://dac-static.atlassian.com) to find subtask issue types).  *  &#x60;parent&#x60; the must contain the ID or key of the parent issue.  **[Permissions](https://dac-static.atlassian.com) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which each issue or subtask is created.
     * @param requestBody  (required)
     * @return BulkCreateIssueRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Returned if any of the issue or subtask creation requests were successful. A request may be unsuccessful when it:   *  is missing required fields.  *  contains invalid field values.  *  contains fields that cannot be set for the issue type.  *  is by a user who does not have the necessary permission.  *  is to create a subtype in a project different that of the parent issue.  *  is for a subtask when the option to create subtasks is disabled.  *  is invalid for any other reason. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
     </table>
     */
    public BulkCreateIssueRequestBuilder bulkCreateIssue() throws IllegalArgumentException {
        return new BulkCreateIssueRequestBuilder();
    }
    private okhttp3.Call createOrUpdateIssueCall(Map<String, Object> requestBody, Boolean updateHistory, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = requestBody;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (updateHistory != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("updateHistory", updateHistory));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createOrUpdateIssueValidateBeforeCall(Map<String, Object> requestBody, Boolean updateHistory, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'requestBody' is set
        if (requestBody == null) {
            throw new ApiException("Missing the required parameter 'requestBody' when calling createOrUpdateIssue(Async)");
        }

        return createOrUpdateIssueCall(requestBody, updateHistory, _callback);

    }


    private ApiResponse<CreatedIssue> createOrUpdateIssueWithHttpInfo(Map<String, Object> requestBody, Boolean updateHistory) throws ApiException {
        okhttp3.Call localVarCall = createOrUpdateIssueValidateBeforeCall(requestBody, updateHistory, null);
        Type localVarReturnType = new TypeToken<CreatedIssue>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createOrUpdateIssueAsync(Map<String, Object> requestBody, Boolean updateHistory, final ApiCallback<CreatedIssue> _callback) throws ApiException {

        okhttp3.Call localVarCall = createOrUpdateIssueValidateBeforeCall(requestBody, updateHistory, _callback);
        Type localVarReturnType = new TypeToken<CreatedIssue>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateOrUpdateIssueRequestBuilder {
        private Map<String, Object> fields;
        private HistoryMetadata historyMetadata;
        private List<EntityProperty> properties;
        private IssueTransition transition;
        private Map<String, List<FieldUpdateOperation>> update;
        private Boolean updateHistory;

        private CreateOrUpdateIssueRequestBuilder() {
        }

        /**
         * Set fields
         * @param fields List of issue screen fields to update, specifying the sub-field to update and its value for each field. This field provides a straightforward option when setting a sub-field. When multiple sub-fields or other operations are required, use &#x60;update&#x60;. Fields included in here cannot be included in &#x60;update&#x60;. (optional)
         * @return CreateOrUpdateIssueRequestBuilder
         */
        public CreateOrUpdateIssueRequestBuilder fields(Map<String, Object> fields) {
            this.fields = fields;
            return this;
        }
        
        /**
         * Set historyMetadata
         * @param historyMetadata  (optional)
         * @return CreateOrUpdateIssueRequestBuilder
         */
        public CreateOrUpdateIssueRequestBuilder historyMetadata(HistoryMetadata historyMetadata) {
            this.historyMetadata = historyMetadata;
            return this;
        }
        
        /**
         * Set properties
         * @param properties Details of issue properties to be add or update. (optional)
         * @return CreateOrUpdateIssueRequestBuilder
         */
        public CreateOrUpdateIssueRequestBuilder properties(List<EntityProperty> properties) {
            this.properties = properties;
            return this;
        }
        
        /**
         * Set transition
         * @param transition  (optional)
         * @return CreateOrUpdateIssueRequestBuilder
         */
        public CreateOrUpdateIssueRequestBuilder transition(IssueTransition transition) {
            this.transition = transition;
            return this;
        }
        
        /**
         * Set update
         * @param update A Map containing the field field name and a list of operations to perform on the issue screen field. Note that fields included in here cannot be included in &#x60;fields&#x60;. (optional)
         * @return CreateOrUpdateIssueRequestBuilder
         */
        public CreateOrUpdateIssueRequestBuilder update(Map<String, List<FieldUpdateOperation>> update) {
            this.update = update;
            return this;
        }
        
        /**
         * Set updateHistory
         * @param updateHistory Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. When provided, the issue type and request type are added to the user&#39;s history for a project. These values are then used to provide defaults on the issue create screen. (optional, default to false)
         * @return CreateOrUpdateIssueRequestBuilder
         */
        public CreateOrUpdateIssueRequestBuilder updateHistory(Boolean updateHistory) {
            this.updateHistory = updateHistory;
            return this;
        }
        
        /**
         * Build call for createOrUpdateIssue
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return createOrUpdateIssueCall(requestBody, updateHistory, _callback);
        }

        private Map<String, Object> buildBodyParams() {
            Map<String, Object> requestBody = new HashMap<String, Object>();
            requestBody.put("fields", this.fields);
            requestBody.put("historyMetadata", this.historyMetadata);
            requestBody.put("properties", this.properties);
            requestBody.put("transition", this.transition);
            requestBody.put("update", this.update);
            return requestBody;
        }

        /**
         * Execute createOrUpdateIssue request
         * @return CreatedIssue
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
         </table>
         */
        public CreatedIssue execute() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            ApiResponse<CreatedIssue> localVarResp = createOrUpdateIssueWithHttpInfo(requestBody, updateHistory);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createOrUpdateIssue request with HTTP info returned
         * @return ApiResponse&lt;CreatedIssue&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<CreatedIssue> executeWithHttpInfo() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return createOrUpdateIssueWithHttpInfo(requestBody, updateHistory);
        }

        /**
         * Execute createOrUpdateIssue request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<CreatedIssue> _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return createOrUpdateIssueAsync(requestBody, updateHistory, _callback);
        }
    }

    /**
     * Create issue
     * Creates an issue or, where the option to create subtasks is enabled in Jira, a subtask. A transition may be applied, to move the issue or subtask to a workflow step other than the default start step, and issue properties set.  The content of the issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [Get create issue metadata](https://dac-static.atlassian.com). These are the same fields that appear on the issue&#39;s create screen. Note that the &#x60;description&#x60;, &#x60;environment&#x60;, and any &#x60;textarea&#x60; type custom fields (multi-line text fields) take Atlassian Document Format content. Single line custom fields (&#x60;textfield&#x60;) accept a string and don&#39;t handle Atlassian Document Format content.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [Get create issue metadata](https://dac-static.atlassian.com) to find subtask issue types).  *  &#x60;parent&#x60; must contain the ID or key of the parent issue.  In a next-gen project any issue may be made a child providing that the parent and child are members of the same project.  **[Permissions](https://dac-static.atlassian.com) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which the issue or subtask is created.
     * @param requestBody  (required)
     * @return CreateOrUpdateIssueRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
     </table>
     */
    public CreateOrUpdateIssueRequestBuilder createOrUpdateIssue() throws IllegalArgumentException {
        return new CreateOrUpdateIssueRequestBuilder();
    }
    private okhttp3.Call deleteIssueByIdOrKeyCall(String issueIdOrKey, String deleteSubtasks, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/{issueIdOrKey}"
            .replace("{" + "issueIdOrKey" + "}", localVarApiClient.escapeString(issueIdOrKey.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (deleteSubtasks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("deleteSubtasks", deleteSubtasks));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteIssueByIdOrKeyValidateBeforeCall(String issueIdOrKey, String deleteSubtasks, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueIdOrKey' is set
        if (issueIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'issueIdOrKey' when calling deleteIssueByIdOrKey(Async)");
        }

        return deleteIssueByIdOrKeyCall(issueIdOrKey, deleteSubtasks, _callback);

    }


    private ApiResponse<Void> deleteIssueByIdOrKeyWithHttpInfo(String issueIdOrKey, String deleteSubtasks) throws ApiException {
        okhttp3.Call localVarCall = deleteIssueByIdOrKeyValidateBeforeCall(issueIdOrKey, deleteSubtasks, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteIssueByIdOrKeyAsync(String issueIdOrKey, String deleteSubtasks, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteIssueByIdOrKeyValidateBeforeCall(issueIdOrKey, deleteSubtasks, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteIssueByIdOrKeyRequestBuilder {
        private final String issueIdOrKey;
        private String deleteSubtasks;

        private DeleteIssueByIdOrKeyRequestBuilder(String issueIdOrKey) {
            this.issueIdOrKey = issueIdOrKey;
        }

        /**
         * Set deleteSubtasks
         * @param deleteSubtasks Whether the issue&#39;s subtasks are deleted when the issue is deleted. (optional, default to false)
         * @return DeleteIssueByIdOrKeyRequestBuilder
         */
        public DeleteIssueByIdOrKeyRequestBuilder deleteSubtasks(String deleteSubtasks) {
            this.deleteSubtasks = deleteSubtasks;
            return this;
        }
        
        /**
         * Build call for deleteIssueByIdOrKey
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the issue has subtasks and &#x60;deleteSubtasks&#x60; is not set to *true*. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user does not have permission to delete the issue. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view the issue. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteIssueByIdOrKeyCall(issueIdOrKey, deleteSubtasks, _callback);
        }


        /**
         * Execute deleteIssueByIdOrKey request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the issue has subtasks and &#x60;deleteSubtasks&#x60; is not set to *true*. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user does not have permission to delete the issue. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view the issue. </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deleteIssueByIdOrKeyWithHttpInfo(issueIdOrKey, deleteSubtasks);
        }

        /**
         * Execute deleteIssueByIdOrKey request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the issue has subtasks and &#x60;deleteSubtasks&#x60; is not set to *true*. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user does not have permission to delete the issue. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view the issue. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deleteIssueByIdOrKeyWithHttpInfo(issueIdOrKey, deleteSubtasks);
        }

        /**
         * Execute deleteIssueByIdOrKey request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the issue has subtasks and &#x60;deleteSubtasks&#x60; is not set to *true*. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user does not have permission to delete the issue. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view the issue. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deleteIssueByIdOrKeyAsync(issueIdOrKey, deleteSubtasks, _callback);
        }
    }

    /**
     * Delete issue
     * Deletes an issue.  An issue cannot be deleted if it has one or more subtasks. To delete an issue with subtasks, set &#x60;deleteSubtasks&#x60;. This causes the issue&#39;s subtasks to be deleted with the issue.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:**   *  *Browse projects* and *Delete issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * @param issueIdOrKey The ID or key of the issue. (required)
     * @return DeleteIssueByIdOrKeyRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if the issue has subtasks and &#x60;deleteSubtasks&#x60; is not set to *true*. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Returned if the user does not have permission to delete the issue. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view the issue. </td><td>  -  </td></tr>
     </table>
     */
    public DeleteIssueByIdOrKeyRequestBuilder deleteIssueByIdOrKey(String issueIdOrKey) throws IllegalArgumentException {
        if (issueIdOrKey == null) throw new IllegalArgumentException("\"issueIdOrKey\" is required but got null");
            

        return new DeleteIssueByIdOrKeyRequestBuilder(issueIdOrKey);
    }
    private okhttp3.Call editIssueByIdOrKeyCall(String issueIdOrKey, Map<String, Object> requestBody, Boolean notifyUsers, Boolean overrideScreenSecurity, Boolean overrideEditableFlag, Boolean returnIssue, String expand, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = requestBody;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/{issueIdOrKey}"
            .replace("{" + "issueIdOrKey" + "}", localVarApiClient.escapeString(issueIdOrKey.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (notifyUsers != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("notifyUsers", notifyUsers));
        }

        if (overrideScreenSecurity != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("overrideScreenSecurity", overrideScreenSecurity));
        }

        if (overrideEditableFlag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("overrideEditableFlag", overrideEditableFlag));
        }

        if (returnIssue != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("returnIssue", returnIssue));
        }

        if (expand != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expand", expand));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call editIssueByIdOrKeyValidateBeforeCall(String issueIdOrKey, Map<String, Object> requestBody, Boolean notifyUsers, Boolean overrideScreenSecurity, Boolean overrideEditableFlag, Boolean returnIssue, String expand, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueIdOrKey' is set
        if (issueIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'issueIdOrKey' when calling editIssueByIdOrKey(Async)");
        }

        // verify the required parameter 'requestBody' is set
        if (requestBody == null) {
            throw new ApiException("Missing the required parameter 'requestBody' when calling editIssueByIdOrKey(Async)");
        }

        return editIssueByIdOrKeyCall(issueIdOrKey, requestBody, notifyUsers, overrideScreenSecurity, overrideEditableFlag, returnIssue, expand, _callback);

    }


    private ApiResponse<Object> editIssueByIdOrKeyWithHttpInfo(String issueIdOrKey, Map<String, Object> requestBody, Boolean notifyUsers, Boolean overrideScreenSecurity, Boolean overrideEditableFlag, Boolean returnIssue, String expand) throws ApiException {
        okhttp3.Call localVarCall = editIssueByIdOrKeyValidateBeforeCall(issueIdOrKey, requestBody, notifyUsers, overrideScreenSecurity, overrideEditableFlag, returnIssue, expand, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call editIssueByIdOrKeyAsync(String issueIdOrKey, Map<String, Object> requestBody, Boolean notifyUsers, Boolean overrideScreenSecurity, Boolean overrideEditableFlag, Boolean returnIssue, String expand, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = editIssueByIdOrKeyValidateBeforeCall(issueIdOrKey, requestBody, notifyUsers, overrideScreenSecurity, overrideEditableFlag, returnIssue, expand, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class EditIssueByIdOrKeyRequestBuilder {
        private final String issueIdOrKey;
        private Map<String, Object> fields;
        private HistoryMetadata historyMetadata;
        private List<EntityProperty> properties;
        private IssueTransition transition;
        private Map<String, List<FieldUpdateOperation>> update;
        private Boolean notifyUsers;
        private Boolean overrideScreenSecurity;
        private Boolean overrideEditableFlag;
        private Boolean returnIssue;
        private String expand;

        private EditIssueByIdOrKeyRequestBuilder(String issueIdOrKey) {
            this.issueIdOrKey = issueIdOrKey;
        }

        /**
         * Set fields
         * @param fields List of issue screen fields to update, specifying the sub-field to update and its value for each field. This field provides a straightforward option when setting a sub-field. When multiple sub-fields or other operations are required, use &#x60;update&#x60;. Fields included in here cannot be included in &#x60;update&#x60;. (optional)
         * @return EditIssueByIdOrKeyRequestBuilder
         */
        public EditIssueByIdOrKeyRequestBuilder fields(Map<String, Object> fields) {
            this.fields = fields;
            return this;
        }
        
        /**
         * Set historyMetadata
         * @param historyMetadata  (optional)
         * @return EditIssueByIdOrKeyRequestBuilder
         */
        public EditIssueByIdOrKeyRequestBuilder historyMetadata(HistoryMetadata historyMetadata) {
            this.historyMetadata = historyMetadata;
            return this;
        }
        
        /**
         * Set properties
         * @param properties Details of issue properties to be add or update. (optional)
         * @return EditIssueByIdOrKeyRequestBuilder
         */
        public EditIssueByIdOrKeyRequestBuilder properties(List<EntityProperty> properties) {
            this.properties = properties;
            return this;
        }
        
        /**
         * Set transition
         * @param transition  (optional)
         * @return EditIssueByIdOrKeyRequestBuilder
         */
        public EditIssueByIdOrKeyRequestBuilder transition(IssueTransition transition) {
            this.transition = transition;
            return this;
        }
        
        /**
         * Set update
         * @param update A Map containing the field field name and a list of operations to perform on the issue screen field. Note that fields included in here cannot be included in &#x60;fields&#x60;. (optional)
         * @return EditIssueByIdOrKeyRequestBuilder
         */
        public EditIssueByIdOrKeyRequestBuilder update(Map<String, List<FieldUpdateOperation>> update) {
            this.update = update;
            return this;
        }
        
        /**
         * Set notifyUsers
         * @param notifyUsers Whether a notification email about the issue update is sent to all watchers. To disable the notification, administer Jira or administer project permissions are required. If the user doesn&#39;t have the necessary permission the request is ignored. (optional, default to true)
         * @return EditIssueByIdOrKeyRequestBuilder
         */
        public EditIssueByIdOrKeyRequestBuilder notifyUsers(Boolean notifyUsers) {
            this.notifyUsers = notifyUsers;
            return this;
        }
        
        /**
         * Set overrideScreenSecurity
         * @param overrideScreenSecurity Whether screen security is overridden to enable hidden fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)
         * @return EditIssueByIdOrKeyRequestBuilder
         */
        public EditIssueByIdOrKeyRequestBuilder overrideScreenSecurity(Boolean overrideScreenSecurity) {
            this.overrideScreenSecurity = overrideScreenSecurity;
            return this;
        }
        
        /**
         * Set overrideEditableFlag
         * @param overrideEditableFlag Whether screen security is overridden to enable uneditable fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)
         * @return EditIssueByIdOrKeyRequestBuilder
         */
        public EditIssueByIdOrKeyRequestBuilder overrideEditableFlag(Boolean overrideEditableFlag) {
            this.overrideEditableFlag = overrideEditableFlag;
            return this;
        }
        
        /**
         * Set returnIssue
         * @param returnIssue Whether the response should contain the issue with fields edited in this request. The returned issue will have the same format as in the [Get issue API](https://dac-static.atlassian.com). (optional, default to false)
         * @return EditIssueByIdOrKeyRequestBuilder
         */
        public EditIssueByIdOrKeyRequestBuilder returnIssue(Boolean returnIssue) {
            this.returnIssue = returnIssue;
            return this;
        }
        
        /**
         * Set expand
         * @param expand The Get issue API expand parameter to use in the response if the &#x60;returnIssue&#x60; parameter is &#x60;true&#x60;. (optional, default to )
         * @return EditIssueByIdOrKeyRequestBuilder
         */
        public EditIssueByIdOrKeyRequestBuilder expand(String expand) {
            this.expand = expand;
            return this;
        }
        
        /**
         * Build call for editIssueByIdOrKey
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful and the &#x60;returnIssue&#x60; parameter is &#x60;true&#x60; </td><td>  -  </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  the request body is missing.  *  the user does not have the necessary permission to edit one or more fields.  *  the request includes one or more fields that are not found or are not associated with the issue&#39;s edit screen.  *  the request includes an invalid transition. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user uses &#x60;overrideScreenSecurity&#x60; or &#x60;overrideEditableFlag&#x60; but doesn&#39;t have the necessary permission. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> Returned if the issue could not be updated due to a conflicting update. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> Returned if a configuration problem prevents the issue being updated. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return editIssueByIdOrKeyCall(issueIdOrKey, requestBody, notifyUsers, overrideScreenSecurity, overrideEditableFlag, returnIssue, expand, _callback);
        }

        private Map<String, Object> buildBodyParams() {
            Map<String, Object> requestBody = new HashMap<String, Object>();
            requestBody.put("fields", this.fields);
            requestBody.put("historyMetadata", this.historyMetadata);
            requestBody.put("properties", this.properties);
            requestBody.put("transition", this.transition);
            requestBody.put("update", this.update);
            return requestBody;
        }

        /**
         * Execute editIssueByIdOrKey request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful and the &#x60;returnIssue&#x60; parameter is &#x60;true&#x60; </td><td>  -  </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  the request body is missing.  *  the user does not have the necessary permission to edit one or more fields.  *  the request includes one or more fields that are not found or are not associated with the issue&#39;s edit screen.  *  the request includes an invalid transition. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user uses &#x60;overrideScreenSecurity&#x60; or &#x60;overrideEditableFlag&#x60; but doesn&#39;t have the necessary permission. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> Returned if the issue could not be updated due to a conflicting update. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> Returned if a configuration problem prevents the issue being updated. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            ApiResponse<Object> localVarResp = editIssueByIdOrKeyWithHttpInfo(issueIdOrKey, requestBody, notifyUsers, overrideScreenSecurity, overrideEditableFlag, returnIssue, expand);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute editIssueByIdOrKey request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful and the &#x60;returnIssue&#x60; parameter is &#x60;true&#x60; </td><td>  -  </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  the request body is missing.  *  the user does not have the necessary permission to edit one or more fields.  *  the request includes one or more fields that are not found or are not associated with the issue&#39;s edit screen.  *  the request includes an invalid transition. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user uses &#x60;overrideScreenSecurity&#x60; or &#x60;overrideEditableFlag&#x60; but doesn&#39;t have the necessary permission. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> Returned if the issue could not be updated due to a conflicting update. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> Returned if a configuration problem prevents the issue being updated. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return editIssueByIdOrKeyWithHttpInfo(issueIdOrKey, requestBody, notifyUsers, overrideScreenSecurity, overrideEditableFlag, returnIssue, expand);
        }

        /**
         * Execute editIssueByIdOrKey request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful and the &#x60;returnIssue&#x60; parameter is &#x60;true&#x60; </td><td>  -  </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  the request body is missing.  *  the user does not have the necessary permission to edit one or more fields.  *  the request includes one or more fields that are not found or are not associated with the issue&#39;s edit screen.  *  the request includes an invalid transition. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user uses &#x60;overrideScreenSecurity&#x60; or &#x60;overrideEditableFlag&#x60; but doesn&#39;t have the necessary permission. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> Returned if the issue could not be updated due to a conflicting update. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> Returned if a configuration problem prevents the issue being updated. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return editIssueByIdOrKeyAsync(issueIdOrKey, requestBody, notifyUsers, overrideScreenSecurity, overrideEditableFlag, returnIssue, expand, _callback);
        }
    }

    /**
     * Edit issue
     * Edits an issue. Issue properties may be updated as part of the edit. Please note that issue transition will be ignored as it is not supported yet.  The edits to the issue&#39;s fields are defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be edited are determined using [Get edit issue metadata](https://dac-static.atlassian.com).  The parent field may be set by key or ID. For standard issue types, the parent may be removed by setting &#x60;update.parent.set.none&#x60; to *true*. Note that the &#x60;description&#x60;, &#x60;environment&#x60;, and any &#x60;textarea&#x60; type custom fields (multi-line text fields) take Atlassian Document Format content. Single line custom fields (&#x60;textfield&#x60;) accept a string and don&#39;t handle Atlassian Document Format content.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can override the screen security configuration using &#x60;overrideScreenSecurity&#x60; and &#x60;overrideEditableFlag&#x60;.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:**   *  *Browse projects* and *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * @param issueIdOrKey The ID or key of the issue. (required)
     * @param requestBody  (required)
     * @return EditIssueByIdOrKeyRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful and the &#x60;returnIssue&#x60; parameter is &#x60;true&#x60; </td><td>  -  </td></tr>
        <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if:   *  the request body is missing.  *  the user does not have the necessary permission to edit one or more fields.  *  the request includes one or more fields that are not found or are not associated with the issue&#39;s edit screen.  *  the request includes an invalid transition. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Returned if the user uses &#x60;overrideScreenSecurity&#x60; or &#x60;overrideEditableFlag&#x60; but doesn&#39;t have the necessary permission. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Returned if the issue could not be updated due to a conflicting update. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Returned if a configuration problem prevents the issue being updated. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
     </table>
     */
    public EditIssueByIdOrKeyRequestBuilder editIssueByIdOrKey(String issueIdOrKey) throws IllegalArgumentException {
        if (issueIdOrKey == null) throw new IllegalArgumentException("\"issueIdOrKey\" is required but got null");
            

        return new EditIssueByIdOrKeyRequestBuilder(issueIdOrKey);
    }
    private okhttp3.Call exportArchivedIssuesCall(Map<String, Object> requestBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = requestBody;

        // create path and map variables
        String localVarPath = "/rest/api/3/issues/archive/export";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call exportArchivedIssuesValidateBeforeCall(Map<String, Object> requestBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'requestBody' is set
        if (requestBody == null) {
            throw new ApiException("Missing the required parameter 'requestBody' when calling exportArchivedIssues(Async)");
        }

        return exportArchivedIssuesCall(requestBody, _callback);

    }


    private ApiResponse<ExportArchivedIssuesTaskProgressResponse> exportArchivedIssuesWithHttpInfo(Map<String, Object> requestBody) throws ApiException {
        okhttp3.Call localVarCall = exportArchivedIssuesValidateBeforeCall(requestBody, null);
        Type localVarReturnType = new TypeToken<ExportArchivedIssuesTaskProgressResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call exportArchivedIssuesAsync(Map<String, Object> requestBody, final ApiCallback<ExportArchivedIssuesTaskProgressResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = exportArchivedIssuesValidateBeforeCall(requestBody, _callback);
        Type localVarReturnType = new TypeToken<ExportArchivedIssuesTaskProgressResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ExportArchivedIssuesRequestBuilder {
        private List<String> archivedBy;
        private DateRangeFilterRequest archivedDateRange;
        private List<String> issueTypes;
        private List<String> projects;
        private List<String> reporters;

        private ExportArchivedIssuesRequestBuilder() {
        }

        /**
         * Set archivedBy
         * @param archivedBy List archived issues archived by a specified account ID. (optional)
         * @return ExportArchivedIssuesRequestBuilder
         */
        public ExportArchivedIssuesRequestBuilder archivedBy(List<String> archivedBy) {
            this.archivedBy = archivedBy;
            return this;
        }
        
        /**
         * Set archivedDateRange
         * @param archivedDateRange  (optional)
         * @return ExportArchivedIssuesRequestBuilder
         */
        public ExportArchivedIssuesRequestBuilder archivedDateRange(DateRangeFilterRequest archivedDateRange) {
            this.archivedDateRange = archivedDateRange;
            return this;
        }
        
        /**
         * Set issueTypes
         * @param issueTypes List archived issues with a specified issue type ID. (optional)
         * @return ExportArchivedIssuesRequestBuilder
         */
        public ExportArchivedIssuesRequestBuilder issueTypes(List<String> issueTypes) {
            this.issueTypes = issueTypes;
            return this;
        }
        
        /**
         * Set projects
         * @param projects List archived issues with a specified project key. (optional)
         * @return ExportArchivedIssuesRequestBuilder
         */
        public ExportArchivedIssuesRequestBuilder projects(List<String> projects) {
            this.projects = projects;
            return this;
        }
        
        /**
         * Set reporters
         * @param reporters List archived issues where the reporter is a specified account ID. (optional)
         * @return ExportArchivedIssuesRequestBuilder
         */
        public ExportArchivedIssuesRequestBuilder reporters(List<String> reporters) {
            this.reporters = reporters;
            return this;
        }
        
        /**
         * Build call for exportArchivedIssues
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> Returns the details of your export task. You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) API to view the progress of your request. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return exportArchivedIssuesCall(requestBody, _callback);
        }

        private Map<String, Object> buildBodyParams() {
            Map<String, Object> requestBody = new HashMap<String, Object>();
            requestBody.put("archivedBy", this.archivedBy);
            requestBody.put("archivedDateRange", this.archivedDateRange);
            requestBody.put("issueTypes", this.issueTypes);
            requestBody.put("projects", this.projects);
            requestBody.put("reporters", this.reporters);
            return requestBody;
        }

        /**
         * Execute exportArchivedIssues request
         * @return ExportArchivedIssuesTaskProgressResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> Returns the details of your export task. You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) API to view the progress of your request. </td><td>  -  </td></tr>
         </table>
         */
        public ExportArchivedIssuesTaskProgressResponse execute() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            ApiResponse<ExportArchivedIssuesTaskProgressResponse> localVarResp = exportArchivedIssuesWithHttpInfo(requestBody);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute exportArchivedIssues request with HTTP info returned
         * @return ApiResponse&lt;ExportArchivedIssuesTaskProgressResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> Returns the details of your export task. You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) API to view the progress of your request. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ExportArchivedIssuesTaskProgressResponse> executeWithHttpInfo() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return exportArchivedIssuesWithHttpInfo(requestBody);
        }

        /**
         * Execute exportArchivedIssues request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> Returns the details of your export task. You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) API to view the progress of your request. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ExportArchivedIssuesTaskProgressResponse> _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return exportArchivedIssuesAsync(requestBody, _callback);
        }
    }

    /**
     * Export archived issue(s)
     * Enables admins to retrieve details of all archived issues. Upon a successful request, the admin who submitted it will receive an email with a link to download a CSV file with the issue details.  Note that this API only exports the values of system fields and archival-specific fields (&#x60;ArchivedBy&#x60; and &#x60;ArchivedDate&#x60;). Custom fields aren&#39;t supported.  **[Permissions](https://dac-static.atlassian.com) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request can be active at any given time.     
     * @param requestBody You can filter the issues in your request by the &#x60;projects&#x60;, &#x60;archivedBy&#x60;, &#x60;archivedDate&#x60;, &#x60;issueTypes&#x60;, and &#x60;reporters&#x60; fields. All filters are optional. If you don&#39;t provide any filters, you&#39;ll get a list of up to one million archived issues. (required)
     * @return ExportArchivedIssuesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns the details of your export task. You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) API to view the progress of your request. </td><td>  -  </td></tr>
     </table>
     */
    public ExportArchivedIssuesRequestBuilder exportArchivedIssues() throws IllegalArgumentException {
        return new ExportArchivedIssuesRequestBuilder();
    }
    private okhttp3.Call getChangelogsCall(String issueIdOrKey, Integer startAt, Integer maxResults, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/{issueIdOrKey}/changelog"
            .replace("{" + "issueIdOrKey" + "}", localVarApiClient.escapeString(issueIdOrKey.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (startAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startAt", startAt));
        }

        if (maxResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxResults", maxResults));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getChangelogsValidateBeforeCall(String issueIdOrKey, Integer startAt, Integer maxResults, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueIdOrKey' is set
        if (issueIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'issueIdOrKey' when calling getChangelogs(Async)");
        }

        return getChangelogsCall(issueIdOrKey, startAt, maxResults, _callback);

    }


    private ApiResponse<PageBeanChangelog> getChangelogsWithHttpInfo(String issueIdOrKey, Integer startAt, Integer maxResults) throws ApiException {
        okhttp3.Call localVarCall = getChangelogsValidateBeforeCall(issueIdOrKey, startAt, maxResults, null);
        Type localVarReturnType = new TypeToken<PageBeanChangelog>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getChangelogsAsync(String issueIdOrKey, Integer startAt, Integer maxResults, final ApiCallback<PageBeanChangelog> _callback) throws ApiException {

        okhttp3.Call localVarCall = getChangelogsValidateBeforeCall(issueIdOrKey, startAt, maxResults, _callback);
        Type localVarReturnType = new TypeToken<PageBeanChangelog>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetChangelogsRequestBuilder {
        private final String issueIdOrKey;
        private Integer startAt;
        private Integer maxResults;

        private GetChangelogsRequestBuilder(String issueIdOrKey) {
            this.issueIdOrKey = issueIdOrKey;
        }

        /**
         * Set startAt
         * @param startAt The index of the first item to return in a page of results (page offset). (optional, default to 0)
         * @return GetChangelogsRequestBuilder
         */
        public GetChangelogsRequestBuilder startAt(Integer startAt) {
            this.startAt = startAt;
            return this;
        }
        
        /**
         * Set maxResults
         * @param maxResults The maximum number of items to return per page. (optional, default to 100)
         * @return GetChangelogsRequestBuilder
         */
        public GetChangelogsRequestBuilder maxResults(Integer maxResults) {
            this.maxResults = maxResults;
            return this;
        }
        
        /**
         * Build call for getChangelogs
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getChangelogsCall(issueIdOrKey, startAt, maxResults, _callback);
        }


        /**
         * Execute getChangelogs request
         * @return PageBeanChangelog
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public PageBeanChangelog execute() throws ApiException {
            ApiResponse<PageBeanChangelog> localVarResp = getChangelogsWithHttpInfo(issueIdOrKey, startAt, maxResults);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getChangelogs request with HTTP info returned
         * @return ApiResponse&lt;PageBeanChangelog&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<PageBeanChangelog> executeWithHttpInfo() throws ApiException {
            return getChangelogsWithHttpInfo(issueIdOrKey, startAt, maxResults);
        }

        /**
         * Execute getChangelogs request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<PageBeanChangelog> _callback) throws ApiException {
            return getChangelogsAsync(issueIdOrKey, startAt, maxResults, _callback);
        }
    }

    /**
     * Get changelogs
     * Returns a [paginated](https://dac-static.atlassian.com) list of all changelogs for an issue sorted by date, starting from the oldest.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * @param issueIdOrKey The ID or key of the issue. (required)
     * @return GetChangelogsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
     </table>
     */
    public GetChangelogsRequestBuilder getChangelogs(String issueIdOrKey) throws IllegalArgumentException {
        if (issueIdOrKey == null) throw new IllegalArgumentException("\"issueIdOrKey\" is required but got null");
            

        return new GetChangelogsRequestBuilder(issueIdOrKey);
    }
    private okhttp3.Call getChangelogsByIdsCall(String issueIdOrKey, IssueChangelogIds issueChangelogIds, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = issueChangelogIds;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/{issueIdOrKey}/changelog/list"
            .replace("{" + "issueIdOrKey" + "}", localVarApiClient.escapeString(issueIdOrKey.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getChangelogsByIdsValidateBeforeCall(String issueIdOrKey, IssueChangelogIds issueChangelogIds, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueIdOrKey' is set
        if (issueIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'issueIdOrKey' when calling getChangelogsByIds(Async)");
        }

        // verify the required parameter 'issueChangelogIds' is set
        if (issueChangelogIds == null) {
            throw new ApiException("Missing the required parameter 'issueChangelogIds' when calling getChangelogsByIds(Async)");
        }

        return getChangelogsByIdsCall(issueIdOrKey, issueChangelogIds, _callback);

    }


    private ApiResponse<PageOfChangelogs> getChangelogsByIdsWithHttpInfo(String issueIdOrKey, IssueChangelogIds issueChangelogIds) throws ApiException {
        okhttp3.Call localVarCall = getChangelogsByIdsValidateBeforeCall(issueIdOrKey, issueChangelogIds, null);
        Type localVarReturnType = new TypeToken<PageOfChangelogs>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getChangelogsByIdsAsync(String issueIdOrKey, IssueChangelogIds issueChangelogIds, final ApiCallback<PageOfChangelogs> _callback) throws ApiException {

        okhttp3.Call localVarCall = getChangelogsByIdsValidateBeforeCall(issueIdOrKey, issueChangelogIds, _callback);
        Type localVarReturnType = new TypeToken<PageOfChangelogs>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetChangelogsByIdsRequestBuilder {
        private final Set<Long> changelogIds;
        private final String issueIdOrKey;

        private GetChangelogsByIdsRequestBuilder(Set<Long> changelogIds, String issueIdOrKey) {
            this.changelogIds = changelogIds;
            this.issueIdOrKey = issueIdOrKey;
        }

        /**
         * Build call for getChangelogsByIds
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the request is not valid. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have the necessary permission. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            IssueChangelogIds issueChangelogIds = buildBodyParams();
            return getChangelogsByIdsCall(issueIdOrKey, issueChangelogIds, _callback);
        }

        private IssueChangelogIds buildBodyParams() {
            IssueChangelogIds issueChangelogIds = new IssueChangelogIds();
            issueChangelogIds.changelogIds(this.changelogIds);
            return issueChangelogIds;
        }

        /**
         * Execute getChangelogsByIds request
         * @return PageOfChangelogs
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the request is not valid. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have the necessary permission. </td><td>  -  </td></tr>
         </table>
         */
        public PageOfChangelogs execute() throws ApiException {
            IssueChangelogIds issueChangelogIds = buildBodyParams();
            ApiResponse<PageOfChangelogs> localVarResp = getChangelogsByIdsWithHttpInfo(issueIdOrKey, issueChangelogIds);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getChangelogsByIds request with HTTP info returned
         * @return ApiResponse&lt;PageOfChangelogs&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the request is not valid. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have the necessary permission. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<PageOfChangelogs> executeWithHttpInfo() throws ApiException {
            IssueChangelogIds issueChangelogIds = buildBodyParams();
            return getChangelogsByIdsWithHttpInfo(issueIdOrKey, issueChangelogIds);
        }

        /**
         * Execute getChangelogsByIds request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the request is not valid. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have the necessary permission. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<PageOfChangelogs> _callback) throws ApiException {
            IssueChangelogIds issueChangelogIds = buildBodyParams();
            return getChangelogsByIdsAsync(issueIdOrKey, issueChangelogIds, _callback);
        }
    }

    /**
     * Get changelogs by IDs
     * Returns changelogs for an issue specified by a list of changelog IDs.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * @param issueIdOrKey The ID or key of the issue. (required)
     * @param issueChangelogIds  (required)
     * @return GetChangelogsByIdsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if the request is not valid. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have the necessary permission. </td><td>  -  </td></tr>
     </table>
     */
    public GetChangelogsByIdsRequestBuilder getChangelogsByIds(Set<Long> changelogIds, String issueIdOrKey) throws IllegalArgumentException {
        if (changelogIds == null) throw new IllegalArgumentException("\"changelogIds\" is required but got null");
        if (issueIdOrKey == null) throw new IllegalArgumentException("\"issueIdOrKey\" is required but got null");
            

        return new GetChangelogsByIdsRequestBuilder(changelogIds, issueIdOrKey);
    }
    private okhttp3.Call getCreateIssueMetaCall(List<String> projectIds, List<String> projectKeys, List<String> issuetypeIds, List<String> issuetypeNames, String expand, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/createmeta";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (projectIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "projectIds", projectIds));
        }

        if (projectKeys != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "projectKeys", projectKeys));
        }

        if (issuetypeIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "issuetypeIds", issuetypeIds));
        }

        if (issuetypeNames != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "issuetypeNames", issuetypeNames));
        }

        if (expand != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expand", expand));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCreateIssueMetaValidateBeforeCall(List<String> projectIds, List<String> projectKeys, List<String> issuetypeIds, List<String> issuetypeNames, String expand, final ApiCallback _callback) throws ApiException {
        return getCreateIssueMetaCall(projectIds, projectKeys, issuetypeIds, issuetypeNames, expand, _callback);

    }


    private ApiResponse<IssueCreateMetadata> getCreateIssueMetaWithHttpInfo(List<String> projectIds, List<String> projectKeys, List<String> issuetypeIds, List<String> issuetypeNames, String expand) throws ApiException {
        okhttp3.Call localVarCall = getCreateIssueMetaValidateBeforeCall(projectIds, projectKeys, issuetypeIds, issuetypeNames, expand, null);
        Type localVarReturnType = new TypeToken<IssueCreateMetadata>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getCreateIssueMetaAsync(List<String> projectIds, List<String> projectKeys, List<String> issuetypeIds, List<String> issuetypeNames, String expand, final ApiCallback<IssueCreateMetadata> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCreateIssueMetaValidateBeforeCall(projectIds, projectKeys, issuetypeIds, issuetypeNames, expand, _callback);
        Type localVarReturnType = new TypeToken<IssueCreateMetadata>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetCreateIssueMetaRequestBuilder {
        private List<String> projectIds;
        private List<String> projectKeys;
        private List<String> issuetypeIds;
        private List<String> issuetypeNames;
        private String expand;

        private GetCreateIssueMetaRequestBuilder() {
        }

        /**
         * Set projectIds
         * @param projectIds List of project IDs. This parameter accepts a comma-separated list. Multiple project IDs can also be provided using an ampersand-separated list. For example, &#x60;projectIds&#x3D;10000,10001&amp;projectIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;projectKeys&#x60;. (optional)
         * @return GetCreateIssueMetaRequestBuilder
         */
        public GetCreateIssueMetaRequestBuilder projectIds(List<String> projectIds) {
            this.projectIds = projectIds;
            return this;
        }
        
        /**
         * Set projectKeys
         * @param projectKeys List of project keys. This parameter accepts a comma-separated list. Multiple project keys can also be provided using an ampersand-separated list. For example, &#x60;projectKeys&#x3D;proj1,proj2&amp;projectKeys&#x3D;proj3&#x60;. This parameter may be provided with &#x60;projectIds&#x60;. (optional)
         * @return GetCreateIssueMetaRequestBuilder
         */
        public GetCreateIssueMetaRequestBuilder projectKeys(List<String> projectKeys) {
            this.projectKeys = projectKeys;
            return this;
        }
        
        /**
         * Set issuetypeIds
         * @param issuetypeIds List of issue type IDs. This parameter accepts a comma-separated list. Multiple issue type IDs can also be provided using an ampersand-separated list. For example, &#x60;issuetypeIds&#x3D;10000,10001&amp;issuetypeIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;issuetypeNames&#x60;. (optional)
         * @return GetCreateIssueMetaRequestBuilder
         */
        public GetCreateIssueMetaRequestBuilder issuetypeIds(List<String> issuetypeIds) {
            this.issuetypeIds = issuetypeIds;
            return this;
        }
        
        /**
         * Set issuetypeNames
         * @param issuetypeNames List of issue type names. This parameter accepts a comma-separated list. Multiple issue type names can also be provided using an ampersand-separated list. For example, &#x60;issuetypeNames&#x3D;name1,name2&amp;issuetypeNames&#x3D;name3&#x60;. This parameter may be provided with &#x60;issuetypeIds&#x60;. (optional)
         * @return GetCreateIssueMetaRequestBuilder
         */
        public GetCreateIssueMetaRequestBuilder issuetypeNames(List<String> issuetypeNames) {
            this.issuetypeNames = issuetypeNames;
            return this;
        }
        
        /**
         * Set expand
         * @param expand Use [expand](https://dac-static.atlassian.com) to include additional information about issue metadata in the response. This parameter accepts &#x60;projects.issuetypes.fields&#x60;, which returns information about the fields in the issue creation screen for each issue type. Fields hidden from the screen are not returned. Use the information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Create issue](https://dac-static.atlassian.com) and [Create issues](https://dac-static.atlassian.com). (optional)
         * @return GetCreateIssueMetaRequestBuilder
         */
        public GetCreateIssueMetaRequestBuilder expand(String expand) {
            this.expand = expand;
            return this;
        }
        
        /**
         * Build call for getCreateIssueMeta
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getCreateIssueMetaCall(projectIds, projectKeys, issuetypeIds, issuetypeNames, expand, _callback);
        }


        /**
         * Execute getCreateIssueMeta request
         * @return IssueCreateMetadata
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public IssueCreateMetadata execute() throws ApiException {
            ApiResponse<IssueCreateMetadata> localVarResp = getCreateIssueMetaWithHttpInfo(projectIds, projectKeys, issuetypeIds, issuetypeNames, expand);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getCreateIssueMeta request with HTTP info returned
         * @return ApiResponse&lt;IssueCreateMetadata&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public ApiResponse<IssueCreateMetadata> executeWithHttpInfo() throws ApiException {
            return getCreateIssueMetaWithHttpInfo(projectIds, projectKeys, issuetypeIds, issuetypeNames, expand);
        }

        /**
         * Execute getCreateIssueMeta request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         * @deprecated
         */
        @Deprecated
        public okhttp3.Call executeAsync(final ApiCallback<IssueCreateMetadata> _callback) throws ApiException {
            return getCreateIssueMetaAsync(projectIds, projectKeys, issuetypeIds, issuetypeNames, expand, _callback);
        }
    }

    /**
     * Get create issue metadata
     * Returns details of projects, issue types within projects, and, when requested, the create screen fields for each issue type for the user. Use the information to populate the requests in [Create issue](https://dac-static.atlassian.com) and [Create issues](https://dac-static.atlassian.com).  Deprecated, see [Create Issue Meta Endpoint Deprecation Notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-1304).  The request can be restricted to specific projects or issue types using the query parameters. The response will contain information for the valid projects, issue types, or project and issue type combinations requested. Note that invalid project, issue type, or project and issue type combinations do not generate errors.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
     * @return GetCreateIssueMetaRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
     </table>
     * @deprecated
     */
    @Deprecated
    public GetCreateIssueMetaRequestBuilder getCreateIssueMeta() throws IllegalArgumentException {
        return new GetCreateIssueMetaRequestBuilder();
    }
    private okhttp3.Call getEditMetaCall(String issueIdOrKey, Boolean overrideScreenSecurity, Boolean overrideEditableFlag, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/{issueIdOrKey}/editmeta"
            .replace("{" + "issueIdOrKey" + "}", localVarApiClient.escapeString(issueIdOrKey.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (overrideScreenSecurity != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("overrideScreenSecurity", overrideScreenSecurity));
        }

        if (overrideEditableFlag != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("overrideEditableFlag", overrideEditableFlag));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEditMetaValidateBeforeCall(String issueIdOrKey, Boolean overrideScreenSecurity, Boolean overrideEditableFlag, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueIdOrKey' is set
        if (issueIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'issueIdOrKey' when calling getEditMeta(Async)");
        }

        return getEditMetaCall(issueIdOrKey, overrideScreenSecurity, overrideEditableFlag, _callback);

    }


    private ApiResponse<IssueUpdateMetadata> getEditMetaWithHttpInfo(String issueIdOrKey, Boolean overrideScreenSecurity, Boolean overrideEditableFlag) throws ApiException {
        okhttp3.Call localVarCall = getEditMetaValidateBeforeCall(issueIdOrKey, overrideScreenSecurity, overrideEditableFlag, null);
        Type localVarReturnType = new TypeToken<IssueUpdateMetadata>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getEditMetaAsync(String issueIdOrKey, Boolean overrideScreenSecurity, Boolean overrideEditableFlag, final ApiCallback<IssueUpdateMetadata> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEditMetaValidateBeforeCall(issueIdOrKey, overrideScreenSecurity, overrideEditableFlag, _callback);
        Type localVarReturnType = new TypeToken<IssueUpdateMetadata>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetEditMetaRequestBuilder {
        private final String issueIdOrKey;
        private Boolean overrideScreenSecurity;
        private Boolean overrideEditableFlag;

        private GetEditMetaRequestBuilder(String issueIdOrKey) {
            this.issueIdOrKey = issueIdOrKey;
        }

        /**
         * Set overrideScreenSecurity
         * @param overrideScreenSecurity Whether hidden fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)
         * @return GetEditMetaRequestBuilder
         */
        public GetEditMetaRequestBuilder overrideScreenSecurity(Boolean overrideScreenSecurity) {
            this.overrideScreenSecurity = overrideScreenSecurity;
            return this;
        }
        
        /**
         * Set overrideEditableFlag
         * @param overrideEditableFlag Whether non-editable fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)
         * @return GetEditMetaRequestBuilder
         */
        public GetEditMetaRequestBuilder overrideEditableFlag(Boolean overrideEditableFlag) {
            this.overrideEditableFlag = overrideEditableFlag;
            return this;
        }
        
        /**
         * Build call for getEditMeta
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user uses an override parameter but doesn&#39;t have permission to do so. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getEditMetaCall(issueIdOrKey, overrideScreenSecurity, overrideEditableFlag, _callback);
        }


        /**
         * Execute getEditMeta request
         * @return IssueUpdateMetadata
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user uses an override parameter but doesn&#39;t have permission to do so. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public IssueUpdateMetadata execute() throws ApiException {
            ApiResponse<IssueUpdateMetadata> localVarResp = getEditMetaWithHttpInfo(issueIdOrKey, overrideScreenSecurity, overrideEditableFlag);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getEditMeta request with HTTP info returned
         * @return ApiResponse&lt;IssueUpdateMetadata&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user uses an override parameter but doesn&#39;t have permission to do so. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<IssueUpdateMetadata> executeWithHttpInfo() throws ApiException {
            return getEditMetaWithHttpInfo(issueIdOrKey, overrideScreenSecurity, overrideEditableFlag);
        }

        /**
         * Execute getEditMeta request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user uses an override parameter but doesn&#39;t have permission to do so. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<IssueUpdateMetadata> _callback) throws ApiException {
            return getEditMetaAsync(issueIdOrKey, overrideScreenSecurity, overrideEditableFlag, _callback);
        }
    }

    /**
     * Get edit issue metadata
     * Returns the edit screen fields for an issue that are visible to and editable by the user. Use the information to populate the requests in [Edit issue](https://dac-static.atlassian.com).  This endpoint will check for these conditions:  1.  Field is available on a field screen - through screen, screen scheme, issue type screen scheme, and issue type scheme configuration. &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 2.  Field is visible in the [field configuration](https://support.atlassian.com/jira-cloud-administration/docs/change-a-field-configuration/). &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 3.  Field is shown on the issue: each field has different conditions here. For example: Attachment field only shows if attachments are enabled. Assignee only shows if user has permissions to assign the issue. 4.  If a field is custom then it must have valid custom field context, applicable for its project and issue type. All system fields are assumed to have context in all projects and all issue types. 5.  Issue has a project, issue type, and status defined. 6.  Issue is assigned to a valid workflow, and the current status has assigned a workflow step. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 7.  The current workflow step is editable. This is true by default, but [can be disabled by setting](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) the &#x60;jira.issue.editable&#x60; property to &#x60;false&#x60;. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 8.  User has [Edit issues permission](https://support.atlassian.com/jira-cloud-administration/docs/permissions-for-company-managed-projects/). 9.  Workflow permissions allow editing a field. This is true by default but [can be modified](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) using &#x60;jira.permission.*&#x60; workflow properties.  Fields hidden using [Issue layout settings page](https://support.atlassian.com/jira-software-cloud/docs/configure-field-layout-in-the-issue-view/) remain editable.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can return additional details using:   *  &#x60;overrideScreenSecurity&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if fields are available through screens, and field configuration (conditions 1. and 2. from the list above).  *  &#x60;overrideEditableFlag&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if workflow is present and if the current step is editable (conditions 6. and 7. from the list above).  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  Note: For any fields to be editable the user must have the *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the issue.
     * @param issueIdOrKey The ID or key of the issue. (required)
     * @return GetEditMetaRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Returned if the user uses an override parameter but doesn&#39;t have permission to do so. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
     </table>
     */
    public GetEditMetaRequestBuilder getEditMeta(String issueIdOrKey) throws IllegalArgumentException {
        if (issueIdOrKey == null) throw new IllegalArgumentException("\"issueIdOrKey\" is required but got null");
            

        return new GetEditMetaRequestBuilder(issueIdOrKey);
    }
    private okhttp3.Call getFieldMetadataForProjectAndIssueTypeCall(String projectIdOrKey, String issueTypeId, Integer startAt, Integer maxResults, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/createmeta/{projectIdOrKey}/issuetypes/{issueTypeId}"
            .replace("{" + "projectIdOrKey" + "}", localVarApiClient.escapeString(projectIdOrKey.toString()))
            .replace("{" + "issueTypeId" + "}", localVarApiClient.escapeString(issueTypeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (startAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startAt", startAt));
        }

        if (maxResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxResults", maxResults));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFieldMetadataForProjectAndIssueTypeValidateBeforeCall(String projectIdOrKey, String issueTypeId, Integer startAt, Integer maxResults, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'projectIdOrKey' is set
        if (projectIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'projectIdOrKey' when calling getFieldMetadataForProjectAndIssueType(Async)");
        }

        // verify the required parameter 'issueTypeId' is set
        if (issueTypeId == null) {
            throw new ApiException("Missing the required parameter 'issueTypeId' when calling getFieldMetadataForProjectAndIssueType(Async)");
        }

        return getFieldMetadataForProjectAndIssueTypeCall(projectIdOrKey, issueTypeId, startAt, maxResults, _callback);

    }


    private ApiResponse<PageOfCreateMetaIssueTypeWithField> getFieldMetadataForProjectAndIssueTypeWithHttpInfo(String projectIdOrKey, String issueTypeId, Integer startAt, Integer maxResults) throws ApiException {
        okhttp3.Call localVarCall = getFieldMetadataForProjectAndIssueTypeValidateBeforeCall(projectIdOrKey, issueTypeId, startAt, maxResults, null);
        Type localVarReturnType = new TypeToken<PageOfCreateMetaIssueTypeWithField>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getFieldMetadataForProjectAndIssueTypeAsync(String projectIdOrKey, String issueTypeId, Integer startAt, Integer maxResults, final ApiCallback<PageOfCreateMetaIssueTypeWithField> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFieldMetadataForProjectAndIssueTypeValidateBeforeCall(projectIdOrKey, issueTypeId, startAt, maxResults, _callback);
        Type localVarReturnType = new TypeToken<PageOfCreateMetaIssueTypeWithField>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetFieldMetadataForProjectAndIssueTypeRequestBuilder {
        private final String projectIdOrKey;
        private final String issueTypeId;
        private Integer startAt;
        private Integer maxResults;

        private GetFieldMetadataForProjectAndIssueTypeRequestBuilder(String projectIdOrKey, String issueTypeId) {
            this.projectIdOrKey = projectIdOrKey;
            this.issueTypeId = issueTypeId;
        }

        /**
         * Set startAt
         * @param startAt The index of the first item to return in a page of results (page offset). (optional, default to 0)
         * @return GetFieldMetadataForProjectAndIssueTypeRequestBuilder
         */
        public GetFieldMetadataForProjectAndIssueTypeRequestBuilder startAt(Integer startAt) {
            this.startAt = startAt;
            return this;
        }
        
        /**
         * Set maxResults
         * @param maxResults The maximum number of items to return per page. (optional, default to 50)
         * @return GetFieldMetadataForProjectAndIssueTypeRequestBuilder
         */
        public GetFieldMetadataForProjectAndIssueTypeRequestBuilder maxResults(Integer maxResults) {
            this.maxResults = maxResults;
            return this;
        }
        
        /**
         * Build call for getFieldMetadataForProjectAndIssueType
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getFieldMetadataForProjectAndIssueTypeCall(projectIdOrKey, issueTypeId, startAt, maxResults, _callback);
        }


        /**
         * Execute getFieldMetadataForProjectAndIssueType request
         * @return PageOfCreateMetaIssueTypeWithField
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public PageOfCreateMetaIssueTypeWithField execute() throws ApiException {
            ApiResponse<PageOfCreateMetaIssueTypeWithField> localVarResp = getFieldMetadataForProjectAndIssueTypeWithHttpInfo(projectIdOrKey, issueTypeId, startAt, maxResults);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getFieldMetadataForProjectAndIssueType request with HTTP info returned
         * @return ApiResponse&lt;PageOfCreateMetaIssueTypeWithField&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<PageOfCreateMetaIssueTypeWithField> executeWithHttpInfo() throws ApiException {
            return getFieldMetadataForProjectAndIssueTypeWithHttpInfo(projectIdOrKey, issueTypeId, startAt, maxResults);
        }

        /**
         * Execute getFieldMetadataForProjectAndIssueType request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<PageOfCreateMetaIssueTypeWithField> _callback) throws ApiException {
            return getFieldMetadataForProjectAndIssueTypeAsync(projectIdOrKey, issueTypeId, startAt, maxResults, _callback);
        }
    }

    /**
     * Get create field metadata for a project and issue type id
     * Returns a page of field metadata for a specified project and issuetype id. Use the information to populate the requests in [Create issue](https://dac-static.atlassian.com) and [Create issues](https://dac-static.atlassian.com).  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
     * @param projectIdOrKey The ID or key of the project. (required)
     * @param issueTypeId The issuetype ID. (required)
     * @return GetFieldMetadataForProjectAndIssueTypeRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
     </table>
     */
    public GetFieldMetadataForProjectAndIssueTypeRequestBuilder getFieldMetadataForProjectAndIssueType(String projectIdOrKey, String issueTypeId) throws IllegalArgumentException {
        if (projectIdOrKey == null) throw new IllegalArgumentException("\"projectIdOrKey\" is required but got null");
            

        if (issueTypeId == null) throw new IllegalArgumentException("\"issueTypeId\" is required but got null");
            

        return new GetFieldMetadataForProjectAndIssueTypeRequestBuilder(projectIdOrKey, issueTypeId);
    }
    private okhttp3.Call getIssueDetailsByIdOrKeyCall(String issueIdOrKey, List<String> fields, Boolean fieldsByKeys, String expand, List<String> properties, Boolean updateHistory, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/{issueIdOrKey}"
            .replace("{" + "issueIdOrKey" + "}", localVarApiClient.escapeString(issueIdOrKey.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (fields != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "fields", fields));
        }

        if (fieldsByKeys != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fieldsByKeys", fieldsByKeys));
        }

        if (expand != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expand", expand));
        }

        if (properties != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "properties", properties));
        }

        if (updateHistory != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("updateHistory", updateHistory));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getIssueDetailsByIdOrKeyValidateBeforeCall(String issueIdOrKey, List<String> fields, Boolean fieldsByKeys, String expand, List<String> properties, Boolean updateHistory, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueIdOrKey' is set
        if (issueIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'issueIdOrKey' when calling getIssueDetailsByIdOrKey(Async)");
        }

        return getIssueDetailsByIdOrKeyCall(issueIdOrKey, fields, fieldsByKeys, expand, properties, updateHistory, _callback);

    }


    private ApiResponse<IssueBean> getIssueDetailsByIdOrKeyWithHttpInfo(String issueIdOrKey, List<String> fields, Boolean fieldsByKeys, String expand, List<String> properties, Boolean updateHistory) throws ApiException {
        okhttp3.Call localVarCall = getIssueDetailsByIdOrKeyValidateBeforeCall(issueIdOrKey, fields, fieldsByKeys, expand, properties, updateHistory, null);
        Type localVarReturnType = new TypeToken<IssueBean>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getIssueDetailsByIdOrKeyAsync(String issueIdOrKey, List<String> fields, Boolean fieldsByKeys, String expand, List<String> properties, Boolean updateHistory, final ApiCallback<IssueBean> _callback) throws ApiException {

        okhttp3.Call localVarCall = getIssueDetailsByIdOrKeyValidateBeforeCall(issueIdOrKey, fields, fieldsByKeys, expand, properties, updateHistory, _callback);
        Type localVarReturnType = new TypeToken<IssueBean>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetIssueDetailsByIdOrKeyRequestBuilder {
        private final String issueIdOrKey;
        private List<String> fields;
        private Boolean fieldsByKeys;
        private String expand;
        private List<String> properties;
        private Boolean updateHistory;

        private GetIssueDetailsByIdOrKeyRequestBuilder(String issueIdOrKey) {
            this.issueIdOrKey = issueIdOrKey;
        }

        /**
         * Set fields
         * @param fields A list of fields to return for the issue. This parameter accepts a comma-separated list. Use it to retrieve a subset of fields. Allowed values:   *  &#x60;*all&#x60; Returns all fields.  *  &#x60;*navigable&#x60; Returns navigable fields.  *  Any issue field, prefixed with a minus to exclude.  Examples:   *  &#x60;summary,comment&#x60; Returns only the summary and comments fields.  *  &#x60;-description&#x60; Returns all (default) fields except description.  *  &#x60;*navigable,-comment&#x60; Returns all navigable fields except comment.  This parameter may be specified multiple times. For example, &#x60;fields&#x3D;field1,field2&amp; fields&#x3D;field3&#x60;.  Note: All fields are returned by default. This differs from [Search for issues using JQL (GET)](https://dac-static.atlassian.com) and [Search for issues using JQL (POST)](https://dac-static.atlassian.com) where the default is all navigable fields. (optional)
         * @return GetIssueDetailsByIdOrKeyRequestBuilder
         */
        public GetIssueDetailsByIdOrKeyRequestBuilder fields(List<String> fields) {
            this.fields = fields;
            return this;
        }
        
        /**
         * Set fieldsByKeys
         * @param fieldsByKeys Whether fields in &#x60;fields&#x60; are referenced by keys rather than IDs. This parameter is useful where fields have been added by a connect app and a field&#39;s key may differ from its ID. (optional, default to false)
         * @return GetIssueDetailsByIdOrKeyRequestBuilder
         */
        public GetIssueDetailsByIdOrKeyRequestBuilder fieldsByKeys(Boolean fieldsByKeys) {
            this.fieldsByKeys = fieldsByKeys;
            return this;
        }
        
        /**
         * Set expand
         * @param expand Use [expand](https://dac-static.atlassian.com) to include additional information about the issues in the response. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;renderedFields&#x60; Returns field values rendered in HTML format.  *  &#x60;names&#x60; Returns the display name of each field.  *  &#x60;schema&#x60; Returns the schema describing a field type.  *  &#x60;transitions&#x60; Returns all possible transitions for the issue.  *  &#x60;editmeta&#x60; Returns information about how each field can be edited.  *  &#x60;changelog&#x60; Returns a list of recent updates to an issue, sorted by date, starting from the most recent.  *  &#x60;versionedRepresentations&#x60; Returns a JSON array for each version of a field&#39;s value, with the highest number representing the most recent version. Note: When included in the request, the &#x60;fields&#x60; parameter is ignored. (optional)
         * @return GetIssueDetailsByIdOrKeyRequestBuilder
         */
        public GetIssueDetailsByIdOrKeyRequestBuilder expand(String expand) {
            this.expand = expand;
            return this;
        }
        
        /**
         * Set properties
         * @param properties A list of issue properties to return for the issue. This parameter accepts a comma-separated list. Allowed values:   *  &#x60;*all&#x60; Returns all issue properties.  *  Any issue property key, prefixed with a minus to exclude.  Examples:   *  &#x60;*all&#x60; Returns all properties.  *  &#x60;*all,-prop1&#x60; Returns all properties except &#x60;prop1&#x60;.  *  &#x60;prop1,prop2&#x60; Returns &#x60;prop1&#x60; and &#x60;prop2&#x60; properties.  This parameter may be specified multiple times. For example, &#x60;properties&#x3D;prop1,prop2&amp; properties&#x3D;prop3&#x60;. (optional)
         * @return GetIssueDetailsByIdOrKeyRequestBuilder
         */
        public GetIssueDetailsByIdOrKeyRequestBuilder properties(List<String> properties) {
            this.properties = properties;
            return this;
        }
        
        /**
         * Set updateHistory
         * @param updateHistory Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. This also populates the [JQL issues search](https://dac-static.atlassian.com) &#x60;lastViewed&#x60; field. (optional, default to false)
         * @return GetIssueDetailsByIdOrKeyRequestBuilder
         */
        public GetIssueDetailsByIdOrKeyRequestBuilder updateHistory(Boolean updateHistory) {
            this.updateHistory = updateHistory;
            return this;
        }
        
        /**
         * Build call for getIssueDetailsByIdOrKey
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getIssueDetailsByIdOrKeyCall(issueIdOrKey, fields, fieldsByKeys, expand, properties, updateHistory, _callback);
        }


        /**
         * Execute getIssueDetailsByIdOrKey request
         * @return IssueBean
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public IssueBean execute() throws ApiException {
            ApiResponse<IssueBean> localVarResp = getIssueDetailsByIdOrKeyWithHttpInfo(issueIdOrKey, fields, fieldsByKeys, expand, properties, updateHistory);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getIssueDetailsByIdOrKey request with HTTP info returned
         * @return ApiResponse&lt;IssueBean&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<IssueBean> executeWithHttpInfo() throws ApiException {
            return getIssueDetailsByIdOrKeyWithHttpInfo(issueIdOrKey, fields, fieldsByKeys, expand, properties, updateHistory);
        }

        /**
         * Execute getIssueDetailsByIdOrKey request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<IssueBean> _callback) throws ApiException {
            return getIssueDetailsByIdOrKeyAsync(issueIdOrKey, fields, fieldsByKeys, expand, properties, updateHistory, _callback);
        }
    }

    /**
     * Get issue
     * Returns the details for an issue.  The issue is identified by its ID or key, however, if the identifier doesn&#39;t match an issue, a case-insensitive search and check for moved issues is performed. If a matching issue is found its details are returned, a 302 or other redirect is **not** returned. The issue key returned in the response is the key of the issue found.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * @param issueIdOrKey The ID or key of the issue. (required)
     * @return GetIssueDetailsByIdOrKeyRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
     </table>
     */
    public GetIssueDetailsByIdOrKeyRequestBuilder getIssueDetailsByIdOrKey(String issueIdOrKey) throws IllegalArgumentException {
        if (issueIdOrKey == null) throw new IllegalArgumentException("\"issueIdOrKey\" is required but got null");
            

        return new GetIssueDetailsByIdOrKeyRequestBuilder(issueIdOrKey);
    }
    private okhttp3.Call getMetaIssueTypesForProjectCall(String projectIdOrKey, Integer startAt, Integer maxResults, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/createmeta/{projectIdOrKey}/issuetypes"
            .replace("{" + "projectIdOrKey" + "}", localVarApiClient.escapeString(projectIdOrKey.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (startAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startAt", startAt));
        }

        if (maxResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxResults", maxResults));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMetaIssueTypesForProjectValidateBeforeCall(String projectIdOrKey, Integer startAt, Integer maxResults, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'projectIdOrKey' is set
        if (projectIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'projectIdOrKey' when calling getMetaIssueTypesForProject(Async)");
        }

        return getMetaIssueTypesForProjectCall(projectIdOrKey, startAt, maxResults, _callback);

    }


    private ApiResponse<PageOfCreateMetaIssueTypes> getMetaIssueTypesForProjectWithHttpInfo(String projectIdOrKey, Integer startAt, Integer maxResults) throws ApiException {
        okhttp3.Call localVarCall = getMetaIssueTypesForProjectValidateBeforeCall(projectIdOrKey, startAt, maxResults, null);
        Type localVarReturnType = new TypeToken<PageOfCreateMetaIssueTypes>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getMetaIssueTypesForProjectAsync(String projectIdOrKey, Integer startAt, Integer maxResults, final ApiCallback<PageOfCreateMetaIssueTypes> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMetaIssueTypesForProjectValidateBeforeCall(projectIdOrKey, startAt, maxResults, _callback);
        Type localVarReturnType = new TypeToken<PageOfCreateMetaIssueTypes>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetMetaIssueTypesForProjectRequestBuilder {
        private final String projectIdOrKey;
        private Integer startAt;
        private Integer maxResults;

        private GetMetaIssueTypesForProjectRequestBuilder(String projectIdOrKey) {
            this.projectIdOrKey = projectIdOrKey;
        }

        /**
         * Set startAt
         * @param startAt The index of the first item to return in a page of results (page offset). (optional, default to 0)
         * @return GetMetaIssueTypesForProjectRequestBuilder
         */
        public GetMetaIssueTypesForProjectRequestBuilder startAt(Integer startAt) {
            this.startAt = startAt;
            return this;
        }
        
        /**
         * Set maxResults
         * @param maxResults The maximum number of items to return per page. (optional, default to 50)
         * @return GetMetaIssueTypesForProjectRequestBuilder
         */
        public GetMetaIssueTypesForProjectRequestBuilder maxResults(Integer maxResults) {
            this.maxResults = maxResults;
            return this;
        }
        
        /**
         * Build call for getMetaIssueTypesForProject
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getMetaIssueTypesForProjectCall(projectIdOrKey, startAt, maxResults, _callback);
        }


        /**
         * Execute getMetaIssueTypesForProject request
         * @return PageOfCreateMetaIssueTypes
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public PageOfCreateMetaIssueTypes execute() throws ApiException {
            ApiResponse<PageOfCreateMetaIssueTypes> localVarResp = getMetaIssueTypesForProjectWithHttpInfo(projectIdOrKey, startAt, maxResults);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getMetaIssueTypesForProject request with HTTP info returned
         * @return ApiResponse&lt;PageOfCreateMetaIssueTypes&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<PageOfCreateMetaIssueTypes> executeWithHttpInfo() throws ApiException {
            return getMetaIssueTypesForProjectWithHttpInfo(projectIdOrKey, startAt, maxResults);
        }

        /**
         * Execute getMetaIssueTypesForProject request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<PageOfCreateMetaIssueTypes> _callback) throws ApiException {
            return getMetaIssueTypesForProjectAsync(projectIdOrKey, startAt, maxResults, _callback);
        }
    }

    /**
     * Get create metadata issue types for a project
     * Returns a page of issue type metadata for a specified project. Use the information to populate the requests in [Create issue](https://dac-static.atlassian.com) and [Create issues](https://dac-static.atlassian.com).  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
     * @param projectIdOrKey The ID or key of the project. (required)
     * @return GetMetaIssueTypesForProjectRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
     </table>
     */
    public GetMetaIssueTypesForProjectRequestBuilder getMetaIssueTypesForProject(String projectIdOrKey) throws IllegalArgumentException {
        if (projectIdOrKey == null) throw new IllegalArgumentException("\"projectIdOrKey\" is required but got null");
            

        return new GetMetaIssueTypesForProjectRequestBuilder(projectIdOrKey);
    }
    private okhttp3.Call getTransitionsCall(String issueIdOrKey, String expand, String transitionId, Boolean skipRemoteOnlyCondition, Boolean includeUnavailableTransitions, Boolean sortByOpsBarAndStatus, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/{issueIdOrKey}/transitions"
            .replace("{" + "issueIdOrKey" + "}", localVarApiClient.escapeString(issueIdOrKey.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (expand != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expand", expand));
        }

        if (transitionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("transitionId", transitionId));
        }

        if (skipRemoteOnlyCondition != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("skipRemoteOnlyCondition", skipRemoteOnlyCondition));
        }

        if (includeUnavailableTransitions != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeUnavailableTransitions", includeUnavailableTransitions));
        }

        if (sortByOpsBarAndStatus != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortByOpsBarAndStatus", sortByOpsBarAndStatus));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTransitionsValidateBeforeCall(String issueIdOrKey, String expand, String transitionId, Boolean skipRemoteOnlyCondition, Boolean includeUnavailableTransitions, Boolean sortByOpsBarAndStatus, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueIdOrKey' is set
        if (issueIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'issueIdOrKey' when calling getTransitions(Async)");
        }

        return getTransitionsCall(issueIdOrKey, expand, transitionId, skipRemoteOnlyCondition, includeUnavailableTransitions, sortByOpsBarAndStatus, _callback);

    }


    private ApiResponse<Transitions> getTransitionsWithHttpInfo(String issueIdOrKey, String expand, String transitionId, Boolean skipRemoteOnlyCondition, Boolean includeUnavailableTransitions, Boolean sortByOpsBarAndStatus) throws ApiException {
        okhttp3.Call localVarCall = getTransitionsValidateBeforeCall(issueIdOrKey, expand, transitionId, skipRemoteOnlyCondition, includeUnavailableTransitions, sortByOpsBarAndStatus, null);
        Type localVarReturnType = new TypeToken<Transitions>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getTransitionsAsync(String issueIdOrKey, String expand, String transitionId, Boolean skipRemoteOnlyCondition, Boolean includeUnavailableTransitions, Boolean sortByOpsBarAndStatus, final ApiCallback<Transitions> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTransitionsValidateBeforeCall(issueIdOrKey, expand, transitionId, skipRemoteOnlyCondition, includeUnavailableTransitions, sortByOpsBarAndStatus, _callback);
        Type localVarReturnType = new TypeToken<Transitions>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetTransitionsRequestBuilder {
        private final String issueIdOrKey;
        private String expand;
        private String transitionId;
        private Boolean skipRemoteOnlyCondition;
        private Boolean includeUnavailableTransitions;
        private Boolean sortByOpsBarAndStatus;

        private GetTransitionsRequestBuilder(String issueIdOrKey) {
            this.issueIdOrKey = issueIdOrKey;
        }

        /**
         * Set expand
         * @param expand Use [expand](https://dac-static.atlassian.com) to include additional information about transitions in the response. This parameter accepts &#x60;transitions.fields&#x60;, which returns information about the fields in the transition screen for each transition. Fields hidden from the screen are not returned. Use this information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Transition issue](https://dac-static.atlassian.com). (optional)
         * @return GetTransitionsRequestBuilder
         */
        public GetTransitionsRequestBuilder expand(String expand) {
            this.expand = expand;
            return this;
        }
        
        /**
         * Set transitionId
         * @param transitionId The ID of the transition. (optional)
         * @return GetTransitionsRequestBuilder
         */
        public GetTransitionsRequestBuilder transitionId(String transitionId) {
            this.transitionId = transitionId;
            return this;
        }
        
        /**
         * Set skipRemoteOnlyCondition
         * @param skipRemoteOnlyCondition Whether transitions with the condition *Hide From User Condition* are included in the response. (optional, default to false)
         * @return GetTransitionsRequestBuilder
         */
        public GetTransitionsRequestBuilder skipRemoteOnlyCondition(Boolean skipRemoteOnlyCondition) {
            this.skipRemoteOnlyCondition = skipRemoteOnlyCondition;
            return this;
        }
        
        /**
         * Set includeUnavailableTransitions
         * @param includeUnavailableTransitions Whether details of transitions that fail a condition are included in the response (optional, default to false)
         * @return GetTransitionsRequestBuilder
         */
        public GetTransitionsRequestBuilder includeUnavailableTransitions(Boolean includeUnavailableTransitions) {
            this.includeUnavailableTransitions = includeUnavailableTransitions;
            return this;
        }
        
        /**
         * Set sortByOpsBarAndStatus
         * @param sortByOpsBarAndStatus Whether the transitions are sorted by ops-bar sequence value first then category order (Todo, In Progress, Done) or only by ops-bar sequence value. (optional, default to false)
         * @return GetTransitionsRequestBuilder
         */
        public GetTransitionsRequestBuilder sortByOpsBarAndStatus(Boolean sortByOpsBarAndStatus) {
            this.sortByOpsBarAndStatus = sortByOpsBarAndStatus;
            return this;
        }
        
        /**
         * Build call for getTransitions
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getTransitionsCall(issueIdOrKey, expand, transitionId, skipRemoteOnlyCondition, includeUnavailableTransitions, sortByOpsBarAndStatus, _callback);
        }


        /**
         * Execute getTransitions request
         * @return Transitions
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public Transitions execute() throws ApiException {
            ApiResponse<Transitions> localVarResp = getTransitionsWithHttpInfo(issueIdOrKey, expand, transitionId, skipRemoteOnlyCondition, includeUnavailableTransitions, sortByOpsBarAndStatus);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getTransitions request with HTTP info returned
         * @return ApiResponse&lt;Transitions&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Transitions> executeWithHttpInfo() throws ApiException {
            return getTransitionsWithHttpInfo(issueIdOrKey, expand, transitionId, skipRemoteOnlyCondition, includeUnavailableTransitions, sortByOpsBarAndStatus);
        }

        /**
         * Execute getTransitions request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Transitions> _callback) throws ApiException {
            return getTransitionsAsync(issueIdOrKey, expand, transitionId, skipRemoteOnlyCondition, includeUnavailableTransitions, sortByOpsBarAndStatus, _callback);
        }
    }

    /**
     * Get transitions
     * Returns either all transitions or a transition that can be performed by the user on an issue, based on the issue&#39;s status.  Note, if a request is made for a transition that does not exist or cannot be performed on the issue, given its status, the response will return any empty transitions list.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required: A list or transition is returned only when the user has:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  However, if the user does not have the *Transition issues* [project permission](https://confluence.atlassian.com/x/yodKLg) the response will not list any transitions.
     * @param issueIdOrKey The ID or key of the issue. (required)
     * @return GetTransitionsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
     </table>
     */
    public GetTransitionsRequestBuilder getTransitions(String issueIdOrKey) throws IllegalArgumentException {
        if (issueIdOrKey == null) throw new IllegalArgumentException("\"issueIdOrKey\" is required but got null");
            

        return new GetTransitionsRequestBuilder(issueIdOrKey);
    }
    private okhttp3.Call listAllEventsCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/events";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listAllEventsValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return listAllEventsCall(_callback);

    }


    private ApiResponse<List<IssueEvent>> listAllEventsWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = listAllEventsValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<List<IssueEvent>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listAllEventsAsync(final ApiCallback<List<IssueEvent>> _callback) throws ApiException {

        okhttp3.Call localVarCall = listAllEventsValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<List<IssueEvent>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListAllEventsRequestBuilder {

        private ListAllEventsRequestBuilder() {
        }

        /**
         * Build call for listAllEvents
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user does not have permission to complete this request. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listAllEventsCall(_callback);
        }


        /**
         * Execute listAllEvents request
         * @return List&lt;IssueEvent&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user does not have permission to complete this request. </td><td>  -  </td></tr>
         </table>
         */
        public List<IssueEvent> execute() throws ApiException {
            ApiResponse<List<IssueEvent>> localVarResp = listAllEventsWithHttpInfo();
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listAllEvents request with HTTP info returned
         * @return ApiResponse&lt;List&lt;IssueEvent&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user does not have permission to complete this request. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<IssueEvent>> executeWithHttpInfo() throws ApiException {
            return listAllEventsWithHttpInfo();
        }

        /**
         * Execute listAllEvents request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if the user does not have permission to complete this request. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<IssueEvent>> _callback) throws ApiException {
            return listAllEventsAsync(_callback);
        }
    }

    /**
     * Get events
     * Returns all issue events.  **[Permissions](https://dac-static.atlassian.com) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * @return ListAllEventsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Returned if the user does not have permission to complete this request. </td><td>  -  </td></tr>
     </table>
     */
    public ListAllEventsRequestBuilder listAllEvents() throws IllegalArgumentException {
        return new ListAllEventsRequestBuilder();
    }
    private okhttp3.Call notifyEmailCall(String issueIdOrKey, Map<String, Object> requestBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = requestBody;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/{issueIdOrKey}/notify"
            .replace("{" + "issueIdOrKey" + "}", localVarApiClient.escapeString(issueIdOrKey.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call notifyEmailValidateBeforeCall(String issueIdOrKey, Map<String, Object> requestBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueIdOrKey' is set
        if (issueIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'issueIdOrKey' when calling notifyEmail(Async)");
        }

        // verify the required parameter 'requestBody' is set
        if (requestBody == null) {
            throw new ApiException("Missing the required parameter 'requestBody' when calling notifyEmail(Async)");
        }

        return notifyEmailCall(issueIdOrKey, requestBody, _callback);

    }


    private ApiResponse<Object> notifyEmailWithHttpInfo(String issueIdOrKey, Map<String, Object> requestBody) throws ApiException {
        okhttp3.Call localVarCall = notifyEmailValidateBeforeCall(issueIdOrKey, requestBody, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call notifyEmailAsync(String issueIdOrKey, Map<String, Object> requestBody, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = notifyEmailValidateBeforeCall(issueIdOrKey, requestBody, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class NotifyEmailRequestBuilder {
        private final String issueIdOrKey;
        private String htmlBody;
        private NotificationRecipientsRestrictions restrict;
        private String subject;
        private String textBody;
        private NotificationRecipients to;

        private NotifyEmailRequestBuilder(String issueIdOrKey) {
            this.issueIdOrKey = issueIdOrKey;
        }

        /**
         * Set htmlBody
         * @param htmlBody The HTML body of the email notification for the issue. (optional)
         * @return NotifyEmailRequestBuilder
         */
        public NotifyEmailRequestBuilder htmlBody(String htmlBody) {
            this.htmlBody = htmlBody;
            return this;
        }
        
        /**
         * Set restrict
         * @param restrict  (optional)
         * @return NotifyEmailRequestBuilder
         */
        public NotifyEmailRequestBuilder restrict(NotificationRecipientsRestrictions restrict) {
            this.restrict = restrict;
            return this;
        }
        
        /**
         * Set subject
         * @param subject The subject of the email notification for the issue. If this is not specified, then the subject is set to the issue key and summary. (optional)
         * @return NotifyEmailRequestBuilder
         */
        public NotifyEmailRequestBuilder subject(String subject) {
            this.subject = subject;
            return this;
        }
        
        /**
         * Set textBody
         * @param textBody The plain text body of the email notification for the issue. (optional)
         * @return NotifyEmailRequestBuilder
         */
        public NotifyEmailRequestBuilder textBody(String textBody) {
            this.textBody = textBody;
            return this;
        }
        
        /**
         * Set to
         * @param to  (optional)
         * @return NotifyEmailRequestBuilder
         */
        public NotifyEmailRequestBuilder to(NotificationRecipients to) {
            this.to = to;
            return this;
        }
        
        /**
         * Build call for notifyEmail
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the email is queued for sending. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  the recipient is the same as the calling user.  *  the recipient is invalid. For example, the recipient is set to the assignee, but the issue is unassigned.  *  the request is invalid. For example, required fields are missing or have invalid values. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if:   *  outgoing emails are disabled.  *  no SMTP server is configured. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return notifyEmailCall(issueIdOrKey, requestBody, _callback);
        }

        private Map<String, Object> buildBodyParams() {
            Map<String, Object> requestBody = new HashMap<String, Object>();
            requestBody.put("htmlBody", this.htmlBody);
            requestBody.put("restrict", this.restrict);
            requestBody.put("subject", this.subject);
            requestBody.put("textBody", this.textBody);
            requestBody.put("to", this.to);
            return requestBody;
        }

        /**
         * Execute notifyEmail request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the email is queued for sending. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  the recipient is the same as the calling user.  *  the recipient is invalid. For example, the recipient is set to the assignee, but the issue is unassigned.  *  the request is invalid. For example, required fields are missing or have invalid values. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if:   *  outgoing emails are disabled.  *  no SMTP server is configured. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found. </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            ApiResponse<Object> localVarResp = notifyEmailWithHttpInfo(issueIdOrKey, requestBody);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute notifyEmail request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the email is queued for sending. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  the recipient is the same as the calling user.  *  the recipient is invalid. For example, the recipient is set to the assignee, but the issue is unassigned.  *  the request is invalid. For example, required fields are missing or have invalid values. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if:   *  outgoing emails are disabled.  *  no SMTP server is configured. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return notifyEmailWithHttpInfo(issueIdOrKey, requestBody);
        }

        /**
         * Execute notifyEmail request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the email is queued for sending. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  the recipient is the same as the calling user.  *  the recipient is invalid. For example, the recipient is set to the assignee, but the issue is unassigned.  *  the request is invalid. For example, required fields are missing or have invalid values. </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> Returned if:   *  outgoing emails are disabled.  *  no SMTP server is configured. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return notifyEmailAsync(issueIdOrKey, requestBody, _callback);
        }
    }

    /**
     * Send notification for issue
     * Creates an email notification for an issue and adds it to the mail queue.  **[Permissions](https://dac-static.atlassian.com) required:**   *  *Browse Projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * @param issueIdOrKey ID or key of the issue that the notification is sent for. (required)
     * @param requestBody The request object for the notification and recipients. (required)
     * @return NotifyEmailRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returned if the email is queued for sending. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if:   *  the recipient is the same as the calling user.  *  the recipient is invalid. For example, the recipient is set to the assignee, but the issue is unassigned.  *  the request is invalid. For example, required fields are missing or have invalid values. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Returned if:   *  outgoing emails are disabled.  *  no SMTP server is configured. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Returned if the issue is not found. </td><td>  -  </td></tr>
     </table>
     */
    public NotifyEmailRequestBuilder notifyEmail(String issueIdOrKey) throws IllegalArgumentException {
        if (issueIdOrKey == null) throw new IllegalArgumentException("\"issueIdOrKey\" is required but got null");
            

        return new NotifyEmailRequestBuilder(issueIdOrKey);
    }
    private okhttp3.Call transitionIssueCall(String issueIdOrKey, Map<String, Object> requestBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = requestBody;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/{issueIdOrKey}/transitions"
            .replace("{" + "issueIdOrKey" + "}", localVarApiClient.escapeString(issueIdOrKey.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call transitionIssueValidateBeforeCall(String issueIdOrKey, Map<String, Object> requestBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueIdOrKey' is set
        if (issueIdOrKey == null) {
            throw new ApiException("Missing the required parameter 'issueIdOrKey' when calling transitionIssue(Async)");
        }

        // verify the required parameter 'requestBody' is set
        if (requestBody == null) {
            throw new ApiException("Missing the required parameter 'requestBody' when calling transitionIssue(Async)");
        }

        return transitionIssueCall(issueIdOrKey, requestBody, _callback);

    }


    private ApiResponse<Object> transitionIssueWithHttpInfo(String issueIdOrKey, Map<String, Object> requestBody) throws ApiException {
        okhttp3.Call localVarCall = transitionIssueValidateBeforeCall(issueIdOrKey, requestBody, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call transitionIssueAsync(String issueIdOrKey, Map<String, Object> requestBody, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = transitionIssueValidateBeforeCall(issueIdOrKey, requestBody, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class TransitionIssueRequestBuilder {
        private final String issueIdOrKey;
        private Map<String, Object> fields;
        private HistoryMetadata historyMetadata;
        private List<EntityProperty> properties;
        private IssueTransition transition;
        private Map<String, List<FieldUpdateOperation>> update;

        private TransitionIssueRequestBuilder(String issueIdOrKey) {
            this.issueIdOrKey = issueIdOrKey;
        }

        /**
         * Set fields
         * @param fields List of issue screen fields to update, specifying the sub-field to update and its value for each field. This field provides a straightforward option when setting a sub-field. When multiple sub-fields or other operations are required, use &#x60;update&#x60;. Fields included in here cannot be included in &#x60;update&#x60;. (optional)
         * @return TransitionIssueRequestBuilder
         */
        public TransitionIssueRequestBuilder fields(Map<String, Object> fields) {
            this.fields = fields;
            return this;
        }
        
        /**
         * Set historyMetadata
         * @param historyMetadata  (optional)
         * @return TransitionIssueRequestBuilder
         */
        public TransitionIssueRequestBuilder historyMetadata(HistoryMetadata historyMetadata) {
            this.historyMetadata = historyMetadata;
            return this;
        }
        
        /**
         * Set properties
         * @param properties Details of issue properties to be add or update. (optional)
         * @return TransitionIssueRequestBuilder
         */
        public TransitionIssueRequestBuilder properties(List<EntityProperty> properties) {
            this.properties = properties;
            return this;
        }
        
        /**
         * Set transition
         * @param transition  (optional)
         * @return TransitionIssueRequestBuilder
         */
        public TransitionIssueRequestBuilder transition(IssueTransition transition) {
            this.transition = transition;
            return this;
        }
        
        /**
         * Set update
         * @param update A Map containing the field field name and a list of operations to perform on the issue screen field. Note that fields included in here cannot be included in &#x60;fields&#x60;. (optional)
         * @return TransitionIssueRequestBuilder
         */
        public TransitionIssueRequestBuilder update(Map<String, List<FieldUpdateOperation>> update) {
            this.update = update;
            return this;
        }
        
        /**
         * Build call for transitionIssue
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  no transition is specified.  *  the user does not have permission to transition the issue.  *  a field that isn&#39;t included on the transition screen is defined in &#x60;fields&#x60; or &#x60;update&#x60;.  *  a field is specified in both &#x60;fields&#x60; and &#x60;update&#x60;.  *  the request is invalid for any other reason. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> Returned if the issue could not be updated due to a conflicting update. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> Returned if a configuration problem prevents the creation of the issue. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return transitionIssueCall(issueIdOrKey, requestBody, _callback);
        }

        private Map<String, Object> buildBodyParams() {
            Map<String, Object> requestBody = new HashMap<String, Object>();
            requestBody.put("fields", this.fields);
            requestBody.put("historyMetadata", this.historyMetadata);
            requestBody.put("properties", this.properties);
            requestBody.put("transition", this.transition);
            requestBody.put("update", this.update);
            return requestBody;
        }

        /**
         * Execute transitionIssue request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  no transition is specified.  *  the user does not have permission to transition the issue.  *  a field that isn&#39;t included on the transition screen is defined in &#x60;fields&#x60; or &#x60;update&#x60;.  *  a field is specified in both &#x60;fields&#x60; and &#x60;update&#x60;.  *  the request is invalid for any other reason. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> Returned if the issue could not be updated due to a conflicting update. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> Returned if a configuration problem prevents the creation of the issue. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            ApiResponse<Object> localVarResp = transitionIssueWithHttpInfo(issueIdOrKey, requestBody);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute transitionIssue request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  no transition is specified.  *  the user does not have permission to transition the issue.  *  a field that isn&#39;t included on the transition screen is defined in &#x60;fields&#x60; or &#x60;update&#x60;.  *  a field is specified in both &#x60;fields&#x60; and &#x60;update&#x60;.  *  the request is invalid for any other reason. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> Returned if the issue could not be updated due to a conflicting update. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> Returned if a configuration problem prevents the creation of the issue. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return transitionIssueWithHttpInfo(issueIdOrKey, requestBody);
        }

        /**
         * Execute transitionIssue request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if:   *  no transition is specified.  *  the user does not have permission to transition the issue.  *  a field that isn&#39;t included on the transition screen is defined in &#x60;fields&#x60; or &#x60;update&#x60;.  *  a field is specified in both &#x60;fields&#x60; and &#x60;update&#x60;.  *  the request is invalid for any other reason. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
            <tr><td> 409 </td><td> Returned if the issue could not be updated due to a conflicting update. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
            <tr><td> 422 </td><td> Returned if a configuration problem prevents the creation of the issue. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            Map<String, Object> requestBody = buildBodyParams();
            return transitionIssueAsync(issueIdOrKey, requestBody, _callback);
        }
    }

    /**
     * Transition issue
     * Performs an issue transition and, if the transition has a screen, updates the fields from the transition screen.  sortByCategory To update the fields on the transition screen, specify the fields in the &#x60;fields&#x60; or &#x60;update&#x60; parameters in the request body. Get details about the fields using [Get transitions](https://dac-static.atlassian.com) with the &#x60;transitions.fields&#x60; expand.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:**   *  *Browse projects* and *Transition issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * @param issueIdOrKey The ID or key of the issue. (required)
     * @param requestBody  (required)
     * @return TransitionIssueRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if:   *  no transition is specified.  *  the user does not have permission to transition the issue.  *  a field that isn&#39;t included on the transition screen is defined in &#x60;fields&#x60; or &#x60;update&#x60;.  *  a field is specified in both &#x60;fields&#x60; and &#x60;update&#x60;.  *  the request is invalid for any other reason. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect or missing. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Returned if the issue is not found or the user does not have permission to view it. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Returned if the issue could not be updated due to a conflicting update. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Returned if a configuration problem prevents the creation of the issue. (refer to the [changelog](https://developer.atlassian.com/changelog/#CHANGE-1364) *for more details.* </td><td>  -  </td></tr>
     </table>
     */
    public TransitionIssueRequestBuilder transitionIssue(String issueIdOrKey) throws IllegalArgumentException {
        if (issueIdOrKey == null) throw new IllegalArgumentException("\"issueIdOrKey\" is required but got null");
            

        return new TransitionIssueRequestBuilder(issueIdOrKey);
    }
    private okhttp3.Call unarchiveIssueByIdsPutCall(IssueArchivalSyncRequest issueArchivalSyncRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = issueArchivalSyncRequest;

        // create path and map variables
        String localVarPath = "/rest/api/3/issue/unarchive";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call unarchiveIssueByIdsPutValidateBeforeCall(IssueArchivalSyncRequest issueArchivalSyncRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueArchivalSyncRequest' is set
        if (issueArchivalSyncRequest == null) {
            throw new ApiException("Missing the required parameter 'issueArchivalSyncRequest' when calling unarchiveIssueByIdsPut(Async)");
        }

        return unarchiveIssueByIdsPutCall(issueArchivalSyncRequest, _callback);

    }


    private ApiResponse<IssueArchivalSyncResponse> unarchiveIssueByIdsPutWithHttpInfo(IssueArchivalSyncRequest issueArchivalSyncRequest) throws ApiException {
        okhttp3.Call localVarCall = unarchiveIssueByIdsPutValidateBeforeCall(issueArchivalSyncRequest, null);
        Type localVarReturnType = new TypeToken<IssueArchivalSyncResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call unarchiveIssueByIdsPutAsync(IssueArchivalSyncRequest issueArchivalSyncRequest, final ApiCallback<IssueArchivalSyncResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = unarchiveIssueByIdsPutValidateBeforeCall(issueArchivalSyncRequest, _callback);
        Type localVarReturnType = new TypeToken<IssueArchivalSyncResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UnarchiveIssueByIdsPutRequestBuilder {
        private List<String> issueIdsOrKeys;

        private UnarchiveIssueByIdsPutRequestBuilder() {
        }

        /**
         * Set issueIdsOrKeys
         * @param issueIdsOrKeys  (optional)
         * @return UnarchiveIssueByIdsPutRequestBuilder
         */
        public UnarchiveIssueByIdsPutRequestBuilder issueIdsOrKeys(List<String> issueIdsOrKeys) {
            this.issueIdsOrKeys = issueIdsOrKeys;
            return this;
        }
        
        /**
         * Build call for unarchiveIssueByIdsPut
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if there is at least one valid issue to unarchive in the request. It will return the count of unarchived issues, which also includes the count of the subtasks unarchived, and it will show the detailed errors for those issues which are not unarchived. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            IssueArchivalSyncRequest issueArchivalSyncRequest = buildBodyParams();
            return unarchiveIssueByIdsPutCall(issueArchivalSyncRequest, _callback);
        }

        private IssueArchivalSyncRequest buildBodyParams() {
            IssueArchivalSyncRequest issueArchivalSyncRequest = new IssueArchivalSyncRequest();
            issueArchivalSyncRequest.issueIdsOrKeys(this.issueIdsOrKeys);
            return issueArchivalSyncRequest;
        }

        /**
         * Execute unarchiveIssueByIdsPut request
         * @return IssueArchivalSyncResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if there is at least one valid issue to unarchive in the request. It will return the count of unarchived issues, which also includes the count of the subtasks unarchived, and it will show the detailed errors for those issues which are not unarchived. </td><td>  -  </td></tr>
         </table>
         */
        public IssueArchivalSyncResponse execute() throws ApiException {
            IssueArchivalSyncRequest issueArchivalSyncRequest = buildBodyParams();
            ApiResponse<IssueArchivalSyncResponse> localVarResp = unarchiveIssueByIdsPutWithHttpInfo(issueArchivalSyncRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute unarchiveIssueByIdsPut request with HTTP info returned
         * @return ApiResponse&lt;IssueArchivalSyncResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if there is at least one valid issue to unarchive in the request. It will return the count of unarchived issues, which also includes the count of the subtasks unarchived, and it will show the detailed errors for those issues which are not unarchived. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<IssueArchivalSyncResponse> executeWithHttpInfo() throws ApiException {
            IssueArchivalSyncRequest issueArchivalSyncRequest = buildBodyParams();
            return unarchiveIssueByIdsPutWithHttpInfo(issueArchivalSyncRequest);
        }

        /**
         * Execute unarchiveIssueByIdsPut request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if there is at least one valid issue to unarchive in the request. It will return the count of unarchived issues, which also includes the count of the subtasks unarchived, and it will show the detailed errors for those issues which are not unarchived. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<IssueArchivalSyncResponse> _callback) throws ApiException {
            IssueArchivalSyncRequest issueArchivalSyncRequest = buildBodyParams();
            return unarchiveIssueByIdsPutAsync(issueArchivalSyncRequest, _callback);
        }
    }

    /**
     * Unarchive issue(s) by issue keys/ID
     * Enables admins to unarchive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) unarchived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t unarchive subtasks directly, only through their parent issues  *  you can only unarchive issues from software, service management, and business projects  **[Permissions](https://dac-static.atlassian.com) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
     * @param issueArchivalSyncRequest Contains a list of issue keys or IDs to be unarchived. (required)
     * @return UnarchiveIssueByIdsPutRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if there is at least one valid issue to unarchive in the request. It will return the count of unarchived issues, which also includes the count of the subtasks unarchived, and it will show the detailed errors for those issues which are not unarchived. </td><td>  -  </td></tr>
     </table>
     */
    public UnarchiveIssueByIdsPutRequestBuilder unarchiveIssueByIdsPut() throws IllegalArgumentException {
        return new UnarchiveIssueByIdsPutRequestBuilder();
    }
}
