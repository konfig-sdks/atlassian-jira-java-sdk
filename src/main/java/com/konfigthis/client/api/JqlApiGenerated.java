/*
 * The Jira Cloud platform REST API
 * Jira Cloud platform REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0-SNAPSHOT-9aad01a33a3dae75a5b6aedf98c77d2cbd2f865d
 * Contact: ecosystem@atlassian.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.AutoCompleteSuggestions;
import com.konfigthis.client.model.ConvertedJQLQueries;
import com.konfigthis.client.model.JQLPersonalDataMigrationRequest;
import com.konfigthis.client.model.JQLReferenceData;
import com.konfigthis.client.model.JqlQueriesToParse;
import com.konfigthis.client.model.JqlQueriesToSanitize;
import com.konfigthis.client.model.JqlQueryToSanitize;
import com.konfigthis.client.model.ParsedJqlQueries;
import com.konfigthis.client.model.SanitizedJqlQueries;
import com.konfigthis.client.model.SearchAutoCompleteFilter;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class JqlApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public JqlApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public JqlApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call convertUserIdentifiersToAccountIdsInJqlQueriesCall(JQLPersonalDataMigrationRequest jqLPersonalDataMigrationRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = jqLPersonalDataMigrationRequest;

        // create path and map variables
        String localVarPath = "/rest/api/3/jql/pdcleaner";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call convertUserIdentifiersToAccountIdsInJqlQueriesValidateBeforeCall(JQLPersonalDataMigrationRequest jqLPersonalDataMigrationRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'jqLPersonalDataMigrationRequest' is set
        if (jqLPersonalDataMigrationRequest == null) {
            throw new ApiException("Missing the required parameter 'jqLPersonalDataMigrationRequest' when calling convertUserIdentifiersToAccountIdsInJqlQueries(Async)");
        }

        return convertUserIdentifiersToAccountIdsInJqlQueriesCall(jqLPersonalDataMigrationRequest, _callback);

    }


    private ApiResponse<ConvertedJQLQueries> convertUserIdentifiersToAccountIdsInJqlQueriesWithHttpInfo(JQLPersonalDataMigrationRequest jqLPersonalDataMigrationRequest) throws ApiException {
        okhttp3.Call localVarCall = convertUserIdentifiersToAccountIdsInJqlQueriesValidateBeforeCall(jqLPersonalDataMigrationRequest, null);
        Type localVarReturnType = new TypeToken<ConvertedJQLQueries>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call convertUserIdentifiersToAccountIdsInJqlQueriesAsync(JQLPersonalDataMigrationRequest jqLPersonalDataMigrationRequest, final ApiCallback<ConvertedJQLQueries> _callback) throws ApiException {

        okhttp3.Call localVarCall = convertUserIdentifiersToAccountIdsInJqlQueriesValidateBeforeCall(jqLPersonalDataMigrationRequest, _callback);
        Type localVarReturnType = new TypeToken<ConvertedJQLQueries>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ConvertUserIdentifiersToAccountIdsInJqlQueriesRequestBuilder {
        private List<String> queryStrings;

        private ConvertUserIdentifiersToAccountIdsInJqlQueriesRequestBuilder() {
        }

        /**
         * Set queryStrings
         * @param queryStrings A list of queries with user identifiers. Maximum of 100 queries. (optional)
         * @return ConvertUserIdentifiersToAccountIdsInJqlQueriesRequestBuilder
         */
        public ConvertUserIdentifiersToAccountIdsInJqlQueriesRequestBuilder queryStrings(List<String> queryStrings) {
            this.queryStrings = queryStrings;
            return this;
        }
        
        /**
         * Build call for convertUserIdentifiersToAccountIdsInJqlQueries
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. Note that the JQL queries are returned in the same order that they were passed. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            JQLPersonalDataMigrationRequest jqLPersonalDataMigrationRequest = buildBodyParams();
            return convertUserIdentifiersToAccountIdsInJqlQueriesCall(jqLPersonalDataMigrationRequest, _callback);
        }

        private JQLPersonalDataMigrationRequest buildBodyParams() {
            JQLPersonalDataMigrationRequest jqLPersonalDataMigrationRequest = new JQLPersonalDataMigrationRequest();
            jqLPersonalDataMigrationRequest.queryStrings(this.queryStrings);
            return jqLPersonalDataMigrationRequest;
        }

        /**
         * Execute convertUserIdentifiersToAccountIdsInJqlQueries request
         * @return ConvertedJQLQueries
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. Note that the JQL queries are returned in the same order that they were passed. </td><td>  -  </td></tr>
         </table>
         */
        public ConvertedJQLQueries execute() throws ApiException {
            JQLPersonalDataMigrationRequest jqLPersonalDataMigrationRequest = buildBodyParams();
            ApiResponse<ConvertedJQLQueries> localVarResp = convertUserIdentifiersToAccountIdsInJqlQueriesWithHttpInfo(jqLPersonalDataMigrationRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute convertUserIdentifiersToAccountIdsInJqlQueries request with HTTP info returned
         * @return ApiResponse&lt;ConvertedJQLQueries&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. Note that the JQL queries are returned in the same order that they were passed. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConvertedJQLQueries> executeWithHttpInfo() throws ApiException {
            JQLPersonalDataMigrationRequest jqLPersonalDataMigrationRequest = buildBodyParams();
            return convertUserIdentifiersToAccountIdsInJqlQueriesWithHttpInfo(jqLPersonalDataMigrationRequest);
        }

        /**
         * Execute convertUserIdentifiersToAccountIdsInJqlQueries request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. Note that the JQL queries are returned in the same order that they were passed. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConvertedJQLQueries> _callback) throws ApiException {
            JQLPersonalDataMigrationRequest jqLPersonalDataMigrationRequest = buildBodyParams();
            return convertUserIdentifiersToAccountIdsInJqlQueriesAsync(jqLPersonalDataMigrationRequest, _callback);
        }
    }

    /**
     * Convert user identifiers to account IDs in JQL queries
     * Converts one or more JQL queries with user identifiers (username or user key) to equivalent JQL queries with account IDs.  You may wish to use this operation if your system stores JQL queries and you want to make them GDPR-compliant. For more information about GDPR-related changes, see the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/).  **[Permissions](https://dac-static.atlassian.com) required:** Permission to access Jira.
     * @param jqLPersonalDataMigrationRequest  (required)
     * @return ConvertUserIdentifiersToAccountIdsInJqlQueriesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. Note that the JQL queries are returned in the same order that they were passed. </td><td>  -  </td></tr>
     </table>
     */
    public ConvertUserIdentifiersToAccountIdsInJqlQueriesRequestBuilder convertUserIdentifiersToAccountIdsInJqlQueries() throws IllegalArgumentException {
        return new ConvertUserIdentifiersToAccountIdsInJqlQueriesRequestBuilder();
    }
    private okhttp3.Call getFieldAutoCompleteForQueryStringCall(String fieldName, String fieldValue, String predicateName, String predicateValue, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/jql/autocompletedata/suggestions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (fieldName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fieldName", fieldName));
        }

        if (fieldValue != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fieldValue", fieldValue));
        }

        if (predicateName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("predicateName", predicateName));
        }

        if (predicateValue != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("predicateValue", predicateValue));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFieldAutoCompleteForQueryStringValidateBeforeCall(String fieldName, String fieldValue, String predicateName, String predicateValue, final ApiCallback _callback) throws ApiException {
        return getFieldAutoCompleteForQueryStringCall(fieldName, fieldValue, predicateName, predicateValue, _callback);

    }


    private ApiResponse<AutoCompleteSuggestions> getFieldAutoCompleteForQueryStringWithHttpInfo(String fieldName, String fieldValue, String predicateName, String predicateValue) throws ApiException {
        okhttp3.Call localVarCall = getFieldAutoCompleteForQueryStringValidateBeforeCall(fieldName, fieldValue, predicateName, predicateValue, null);
        Type localVarReturnType = new TypeToken<AutoCompleteSuggestions>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getFieldAutoCompleteForQueryStringAsync(String fieldName, String fieldValue, String predicateName, String predicateValue, final ApiCallback<AutoCompleteSuggestions> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFieldAutoCompleteForQueryStringValidateBeforeCall(fieldName, fieldValue, predicateName, predicateValue, _callback);
        Type localVarReturnType = new TypeToken<AutoCompleteSuggestions>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetFieldAutoCompleteForQueryStringRequestBuilder {
        private String fieldName;
        private String fieldValue;
        private String predicateName;
        private String predicateValue;

        private GetFieldAutoCompleteForQueryStringRequestBuilder() {
        }

        /**
         * Set fieldName
         * @param fieldName The name of the field. (optional)
         * @return GetFieldAutoCompleteForQueryStringRequestBuilder
         */
        public GetFieldAutoCompleteForQueryStringRequestBuilder fieldName(String fieldName) {
            this.fieldName = fieldName;
            return this;
        }
        
        /**
         * Set fieldValue
         * @param fieldValue The partial field item name entered by the user. (optional)
         * @return GetFieldAutoCompleteForQueryStringRequestBuilder
         */
        public GetFieldAutoCompleteForQueryStringRequestBuilder fieldValue(String fieldValue) {
            this.fieldValue = fieldValue;
            return this;
        }
        
        /**
         * Set predicateName
         * @param predicateName The name of the [CHANGED operator predicate](https://confluence.atlassian.com/x/hQORLQ#Advancedsearching-operatorsreference-CHANGEDCHANGED) for which the suggestions are generated. The valid predicate operators are *by*, *from*, and *to*. (optional)
         * @return GetFieldAutoCompleteForQueryStringRequestBuilder
         */
        public GetFieldAutoCompleteForQueryStringRequestBuilder predicateName(String predicateName) {
            this.predicateName = predicateName;
            return this;
        }
        
        /**
         * Set predicateValue
         * @param predicateValue The partial predicate item name entered by the user. (optional)
         * @return GetFieldAutoCompleteForQueryStringRequestBuilder
         */
        public GetFieldAutoCompleteForQueryStringRequestBuilder predicateValue(String predicateValue) {
            this.predicateValue = predicateValue;
            return this;
        }
        
        /**
         * Build call for getFieldAutoCompleteForQueryString
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if an invalid combination of parameters is passed. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getFieldAutoCompleteForQueryStringCall(fieldName, fieldValue, predicateName, predicateValue, _callback);
        }


        /**
         * Execute getFieldAutoCompleteForQueryString request
         * @return AutoCompleteSuggestions
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if an invalid combination of parameters is passed. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public AutoCompleteSuggestions execute() throws ApiException {
            ApiResponse<AutoCompleteSuggestions> localVarResp = getFieldAutoCompleteForQueryStringWithHttpInfo(fieldName, fieldValue, predicateName, predicateValue);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getFieldAutoCompleteForQueryString request with HTTP info returned
         * @return ApiResponse&lt;AutoCompleteSuggestions&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if an invalid combination of parameters is passed. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<AutoCompleteSuggestions> executeWithHttpInfo() throws ApiException {
            return getFieldAutoCompleteForQueryStringWithHttpInfo(fieldName, fieldValue, predicateName, predicateValue);
        }

        /**
         * Execute getFieldAutoCompleteForQueryString request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if an invalid combination of parameters is passed. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<AutoCompleteSuggestions> _callback) throws ApiException {
            return getFieldAutoCompleteForQueryStringAsync(fieldName, fieldValue, predicateName, predicateValue, _callback);
        }
    }

    /**
     * Get field auto complete suggestions
     * Returns the JQL search auto complete suggestions for a field.  Suggestions can be obtained by providing:   *  &#x60;fieldName&#x60; to get a list of all values for the field.  *  &#x60;fieldName&#x60; and &#x60;fieldValue&#x60; to get a list of values containing the text in &#x60;fieldValue&#x60;.  *  &#x60;fieldName&#x60; and &#x60;predicateName&#x60; to get a list of all predicate values for the field.  *  &#x60;fieldName&#x60;, &#x60;predicateName&#x60;, and &#x60;predicateValue&#x60; to get a list of predicate values containing the text in &#x60;predicateValue&#x60;.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:** None.
     * @return GetFieldAutoCompleteForQueryStringRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if an invalid combination of parameters is passed. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
     </table>
     */
    public GetFieldAutoCompleteForQueryStringRequestBuilder getFieldAutoCompleteForQueryString() throws IllegalArgumentException {
        return new GetFieldAutoCompleteForQueryStringRequestBuilder();
    }
    private okhttp3.Call getFieldReferenceDataCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/api/3/jql/autocompletedata";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFieldReferenceDataValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return getFieldReferenceDataCall(_callback);

    }


    private ApiResponse<JQLReferenceData> getFieldReferenceDataWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getFieldReferenceDataValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<JQLReferenceData>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getFieldReferenceDataAsync(final ApiCallback<JQLReferenceData> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFieldReferenceDataValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<JQLReferenceData>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetFieldReferenceDataRequestBuilder {

        private GetFieldReferenceDataRequestBuilder() {
        }

        /**
         * Build call for getFieldReferenceData
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getFieldReferenceDataCall(_callback);
        }


        /**
         * Execute getFieldReferenceData request
         * @return JQLReferenceData
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public JQLReferenceData execute() throws ApiException {
            ApiResponse<JQLReferenceData> localVarResp = getFieldReferenceDataWithHttpInfo();
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getFieldReferenceData request with HTTP info returned
         * @return ApiResponse&lt;JQLReferenceData&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<JQLReferenceData> executeWithHttpInfo() throws ApiException {
            return getFieldReferenceDataWithHttpInfo();
        }

        /**
         * Execute getFieldReferenceData request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<JQLReferenceData> _callback) throws ApiException {
            return getFieldReferenceDataAsync(_callback);
        }
    }

    /**
     * Get field reference data (GET)
     * Returns reference data for JQL searches. This is a downloadable version of the documentation provided in [Advanced searching - fields reference](https://confluence.atlassian.com/x/gwORLQ) and [Advanced searching - functions reference](https://confluence.atlassian.com/x/hgORLQ), along with a list of JQL-reserved words. Use this information to assist with the programmatic creation of JQL queries or the validation of queries built in a custom query builder.  To filter visible field details by project or collapse non-unique fields by field type then [Get field reference data (POST)](https://dac-static.atlassian.com) can be used.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:** None.
     * @return GetFieldReferenceDataRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
     </table>
     */
    public GetFieldReferenceDataRequestBuilder getFieldReferenceData() throws IllegalArgumentException {
        return new GetFieldReferenceDataRequestBuilder();
    }
    private okhttp3.Call getFieldReferenceDataPostCall(SearchAutoCompleteFilter searchAutoCompleteFilter, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchAutoCompleteFilter;

        // create path and map variables
        String localVarPath = "/rest/api/3/jql/autocompletedata";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFieldReferenceDataPostValidateBeforeCall(SearchAutoCompleteFilter searchAutoCompleteFilter, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'searchAutoCompleteFilter' is set
        if (searchAutoCompleteFilter == null) {
            throw new ApiException("Missing the required parameter 'searchAutoCompleteFilter' when calling getFieldReferenceDataPost(Async)");
        }

        return getFieldReferenceDataPostCall(searchAutoCompleteFilter, _callback);

    }


    private ApiResponse<JQLReferenceData> getFieldReferenceDataPostWithHttpInfo(SearchAutoCompleteFilter searchAutoCompleteFilter) throws ApiException {
        okhttp3.Call localVarCall = getFieldReferenceDataPostValidateBeforeCall(searchAutoCompleteFilter, null);
        Type localVarReturnType = new TypeToken<JQLReferenceData>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getFieldReferenceDataPostAsync(SearchAutoCompleteFilter searchAutoCompleteFilter, final ApiCallback<JQLReferenceData> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFieldReferenceDataPostValidateBeforeCall(searchAutoCompleteFilter, _callback);
        Type localVarReturnType = new TypeToken<JQLReferenceData>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetFieldReferenceDataPostRequestBuilder {
        private Boolean includeCollapsedFields;
        private List<Long> projectIds;

        private GetFieldReferenceDataPostRequestBuilder() {
        }

        /**
         * Set includeCollapsedFields
         * @param includeCollapsedFields Include collapsed fields for fields that have non-unique names. (optional, default to false)
         * @return GetFieldReferenceDataPostRequestBuilder
         */
        public GetFieldReferenceDataPostRequestBuilder includeCollapsedFields(Boolean includeCollapsedFields) {
            this.includeCollapsedFields = includeCollapsedFields;
            return this;
        }
        
        /**
         * Set projectIds
         * @param projectIds List of project IDs used to filter the visible field details returned. (optional)
         * @return GetFieldReferenceDataPostRequestBuilder
         */
        public GetFieldReferenceDataPostRequestBuilder projectIds(List<Long> projectIds) {
            this.projectIds = projectIds;
            return this;
        }
        
        /**
         * Build call for getFieldReferenceDataPost
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the request is not valid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            SearchAutoCompleteFilter searchAutoCompleteFilter = buildBodyParams();
            return getFieldReferenceDataPostCall(searchAutoCompleteFilter, _callback);
        }

        private SearchAutoCompleteFilter buildBodyParams() {
            SearchAutoCompleteFilter searchAutoCompleteFilter = new SearchAutoCompleteFilter();
            searchAutoCompleteFilter.includeCollapsedFields(this.includeCollapsedFields);
            searchAutoCompleteFilter.projectIds(this.projectIds);
            return searchAutoCompleteFilter;
        }

        /**
         * Execute getFieldReferenceDataPost request
         * @return JQLReferenceData
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the request is not valid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public JQLReferenceData execute() throws ApiException {
            SearchAutoCompleteFilter searchAutoCompleteFilter = buildBodyParams();
            ApiResponse<JQLReferenceData> localVarResp = getFieldReferenceDataPostWithHttpInfo(searchAutoCompleteFilter);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getFieldReferenceDataPost request with HTTP info returned
         * @return ApiResponse&lt;JQLReferenceData&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the request is not valid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<JQLReferenceData> executeWithHttpInfo() throws ApiException {
            SearchAutoCompleteFilter searchAutoCompleteFilter = buildBodyParams();
            return getFieldReferenceDataPostWithHttpInfo(searchAutoCompleteFilter);
        }

        /**
         * Execute getFieldReferenceDataPost request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> Returned if the request is not valid. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<JQLReferenceData> _callback) throws ApiException {
            SearchAutoCompleteFilter searchAutoCompleteFilter = buildBodyParams();
            return getFieldReferenceDataPostAsync(searchAutoCompleteFilter, _callback);
        }
    }

    /**
     * Get field reference data (POST)
     * Returns reference data for JQL searches. This is a downloadable version of the documentation provided in [Advanced searching - fields reference](https://confluence.atlassian.com/x/gwORLQ) and [Advanced searching - functions reference](https://confluence.atlassian.com/x/hgORLQ), along with a list of JQL-reserved words. Use this information to assist with the programmatic creation of JQL queries or the validation of queries built in a custom query builder.  This operation can filter the custom fields returned by project. Invalid project IDs in &#x60;projectIds&#x60; are ignored. System fields are always returned.  It can also return the collapsed field for custom fields. Collapsed fields enable searches to be performed across all fields with the same name and of the same field type. For example, the collapsed field &#x60;Component - Component[Dropdown]&#x60; enables dropdown fields &#x60;Component - cf[10061]&#x60; and &#x60;Component - cf[10062]&#x60; to be searched simultaneously.  **[Permissions](https://dac-static.atlassian.com) required:** None.
     * @param searchAutoCompleteFilter  (required)
     * @return GetFieldReferenceDataPostRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Returned if the request is not valid. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
     </table>
     */
    public GetFieldReferenceDataPostRequestBuilder getFieldReferenceDataPost() throws IllegalArgumentException {
        return new GetFieldReferenceDataPostRequestBuilder();
    }
    private okhttp3.Call parseAndValidateCall(String validation, JqlQueriesToParse jqlQueriesToParse, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = jqlQueriesToParse;

        // create path and map variables
        String localVarPath = "/rest/api/3/jql/parse";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (validation != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("validation", validation));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call parseAndValidateValidateBeforeCall(String validation, JqlQueriesToParse jqlQueriesToParse, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'validation' is set
        if (validation == null) {
            throw new ApiException("Missing the required parameter 'validation' when calling parseAndValidate(Async)");
        }

        // verify the required parameter 'jqlQueriesToParse' is set
        if (jqlQueriesToParse == null) {
            throw new ApiException("Missing the required parameter 'jqlQueriesToParse' when calling parseAndValidate(Async)");
        }

        return parseAndValidateCall(validation, jqlQueriesToParse, _callback);

    }


    private ApiResponse<ParsedJqlQueries> parseAndValidateWithHttpInfo(String validation, JqlQueriesToParse jqlQueriesToParse) throws ApiException {
        okhttp3.Call localVarCall = parseAndValidateValidateBeforeCall(validation, jqlQueriesToParse, null);
        Type localVarReturnType = new TypeToken<ParsedJqlQueries>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call parseAndValidateAsync(String validation, JqlQueriesToParse jqlQueriesToParse, final ApiCallback<ParsedJqlQueries> _callback) throws ApiException {

        okhttp3.Call localVarCall = parseAndValidateValidateBeforeCall(validation, jqlQueriesToParse, _callback);
        Type localVarReturnType = new TypeToken<ParsedJqlQueries>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ParseAndValidateRequestBuilder {
        private final List<String> queries;
        private final String validation;

        private ParseAndValidateRequestBuilder(List<String> queries, String validation) {
            this.queries = queries;
            this.validation = validation;
        }

        /**
         * Build call for parseAndValidate
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            JqlQueriesToParse jqlQueriesToParse = buildBodyParams();
            return parseAndValidateCall(validation, jqlQueriesToParse, _callback);
        }

        private JqlQueriesToParse buildBodyParams() {
            JqlQueriesToParse jqlQueriesToParse = new JqlQueriesToParse();
            jqlQueriesToParse.queries(this.queries);
            return jqlQueriesToParse;
        }

        /**
         * Execute parseAndValidate request
         * @return ParsedJqlQueries
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public ParsedJqlQueries execute() throws ApiException {
            JqlQueriesToParse jqlQueriesToParse = buildBodyParams();
            ApiResponse<ParsedJqlQueries> localVarResp = parseAndValidateWithHttpInfo(validation, jqlQueriesToParse);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute parseAndValidate request with HTTP info returned
         * @return ApiResponse&lt;ParsedJqlQueries&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ParsedJqlQueries> executeWithHttpInfo() throws ApiException {
            JqlQueriesToParse jqlQueriesToParse = buildBodyParams();
            return parseAndValidateWithHttpInfo(validation, jqlQueriesToParse);
        }

        /**
         * Execute parseAndValidate request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ParsedJqlQueries> _callback) throws ApiException {
            JqlQueriesToParse jqlQueriesToParse = buildBodyParams();
            return parseAndValidateAsync(validation, jqlQueriesToParse, _callback);
        }
    }

    /**
     * Parse JQL query
     * Parses and validates JQL queries.  Validation is performed in context of the current user.  This operation can be accessed anonymously.  **[Permissions](https://dac-static.atlassian.com) required:** None.
     * @param validation How to validate the JQL query and treat the validation results. Validation options include:   *  &#x60;strict&#x60; Returns all errors. If validation fails, the query structure is not returned.  *  &#x60;warn&#x60; Returns all errors. If validation fails but the JQL query is correctly formed, the query structure is returned.  *  &#x60;none&#x60; No validation is performed. If JQL query is correctly formed, the query structure is returned. (required)
     * @param jqlQueriesToParse  (required)
     * @return ParseAndValidateRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Returned if the authentication credentials are incorrect. </td><td>  -  </td></tr>
     </table>
     */
    public ParseAndValidateRequestBuilder parseAndValidate(List<String> queries, String validation) throws IllegalArgumentException {
        if (queries == null) throw new IllegalArgumentException("\"queries\" is required but got null");
        if (validation == null) throw new IllegalArgumentException("\"validation\" is required but got null");
            

        return new ParseAndValidateRequestBuilder(queries, validation);
    }
    private okhttp3.Call sanitizeJqlQueriesCall(JqlQueriesToSanitize jqlQueriesToSanitize, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = jqlQueriesToSanitize;

        // create path and map variables
        String localVarPath = "/rest/api/3/jql/sanitize";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2", "basicAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call sanitizeJqlQueriesValidateBeforeCall(JqlQueriesToSanitize jqlQueriesToSanitize, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'jqlQueriesToSanitize' is set
        if (jqlQueriesToSanitize == null) {
            throw new ApiException("Missing the required parameter 'jqlQueriesToSanitize' when calling sanitizeJqlQueries(Async)");
        }

        return sanitizeJqlQueriesCall(jqlQueriesToSanitize, _callback);

    }


    private ApiResponse<SanitizedJqlQueries> sanitizeJqlQueriesWithHttpInfo(JqlQueriesToSanitize jqlQueriesToSanitize) throws ApiException {
        okhttp3.Call localVarCall = sanitizeJqlQueriesValidateBeforeCall(jqlQueriesToSanitize, null);
        Type localVarReturnType = new TypeToken<SanitizedJqlQueries>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call sanitizeJqlQueriesAsync(JqlQueriesToSanitize jqlQueriesToSanitize, final ApiCallback<SanitizedJqlQueries> _callback) throws ApiException {

        okhttp3.Call localVarCall = sanitizeJqlQueriesValidateBeforeCall(jqlQueriesToSanitize, _callback);
        Type localVarReturnType = new TypeToken<SanitizedJqlQueries>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SanitizeJqlQueriesRequestBuilder {
        private final List<JqlQueryToSanitize> queries;

        private SanitizeJqlQueriesRequestBuilder(List<JqlQueryToSanitize> queries) {
            this.queries = queries;
        }

        /**
         * Build call for sanitizeJqlQueries
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            JqlQueriesToSanitize jqlQueriesToSanitize = buildBodyParams();
            return sanitizeJqlQueriesCall(jqlQueriesToSanitize, _callback);
        }

        private JqlQueriesToSanitize buildBodyParams() {
            JqlQueriesToSanitize jqlQueriesToSanitize = new JqlQueriesToSanitize();
            jqlQueriesToSanitize.queries(this.queries);
            return jqlQueriesToSanitize;
        }

        /**
         * Execute sanitizeJqlQueries request
         * @return SanitizedJqlQueries
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
         </table>
         */
        public SanitizedJqlQueries execute() throws ApiException {
            JqlQueriesToSanitize jqlQueriesToSanitize = buildBodyParams();
            ApiResponse<SanitizedJqlQueries> localVarResp = sanitizeJqlQueriesWithHttpInfo(jqlQueriesToSanitize);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute sanitizeJqlQueries request with HTTP info returned
         * @return ApiResponse&lt;SanitizedJqlQueries&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<SanitizedJqlQueries> executeWithHttpInfo() throws ApiException {
            JqlQueriesToSanitize jqlQueriesToSanitize = buildBodyParams();
            return sanitizeJqlQueriesWithHttpInfo(jqlQueriesToSanitize);
        }

        /**
         * Execute sanitizeJqlQueries request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<SanitizedJqlQueries> _callback) throws ApiException {
            JqlQueriesToSanitize jqlQueriesToSanitize = buildBodyParams();
            return sanitizeJqlQueriesAsync(jqlQueriesToSanitize, _callback);
        }
    }

    /**
     * Sanitize JQL queries
     * Sanitizes one or more JQL queries by converting readable details into IDs where a user doesn&#39;t have permission to view the entity.  For example, if the query contains the clause *project &#x3D; &#39;Secret project&#39;*, and a user does not have browse permission for the project \&quot;Secret project\&quot;, the sanitized query replaces the clause with *project &#x3D; 12345\&quot;* (where 12345 is the ID of the project). If a user has the required permission, the clause is not sanitized. If the account ID is null, sanitizing is performed for an anonymous user.  Note that sanitization doesn&#39;t make the queries GDPR-compliant, because it doesn&#39;t remove user identifiers (username or user key). If you need to make queries GDPR-compliant, use [Convert user identifiers to account IDs in JQL queries](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-jql/#api-rest-api-3-jql-sanitize-post).  Before sanitization each JQL query is parsed. The queries are returned in the same order that they were passed.  **[Permissions](https://dac-static.atlassian.com) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * @param jqlQueriesToSanitize  (required)
     * @return SanitizeJqlQueriesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned if the request is successful. </td><td>  -  </td></tr>
     </table>
     */
    public SanitizeJqlQueriesRequestBuilder sanitizeJqlQueries(List<JqlQueryToSanitize> queries) throws IllegalArgumentException {
        if (queries == null) throw new IllegalArgumentException("\"queries\" is required but got null");
        return new SanitizeJqlQueriesRequestBuilder(queries);
    }
}
